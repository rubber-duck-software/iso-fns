"use strict";(self.webpackChunkiso_fns_docs=self.webpackChunkiso_fns_docs||[]).push([[496],{5933:function(n,e,t){t.d(e,{Z:function(){return m}});var o=t(7294),r=t(9604),a=t(5350),i=[{source:"\n      declare module 'https://cdn.skypack.dev/iso-fns@alpha' {\n      import { IDateFns } from 'types/IDateFns'\n      import { IDateTimeFns } from 'types/IDateTimeFns'\n      import { IInstantFns } from 'types/IInstantFns'\n      import { ITimeFns } from 'types/ITimeFns'\n      import { IMonthDayFns } from 'types/IMonthDayFns'\n      import { IYearMonthFns } from 'types/IYearMonthFns'\n      import { IZonedDateTimeFns } from 'types/IZonedDateTimeFns'\n      import { IDurationFns } from 'types/IDurationFns'\n\n      export * from 'iso-types'\n\n      export const dateFns: IDateFns\n      export const dateTimeFns: IDateTimeFns\n      export const durationFns: IDurationFns\n      export const instantFns: IInstantFns\n      export const monthDayFns: IMonthDayFns\n      export const timeFns: ITimeFns\n      export const yearMonthFns: IYearMonthFns\n      export const zonedDateTimeFns: IZonedDateTimeFns\n    }\n\n    declare module \"iso-types\" {\n    export module Iso {\n        type Offset = `${'+' | '-'}${number}:${number}`;\n        type DateFormat = `${number}-${number}-${number}`;\n        type TimeFormat = `${number}:${number}` | `${number}:${number}:${number}` | `${number}:${number}:${number}.${number}`;\n        type InstantFormat = `${number}-${number}-${number}T${number}:${number}:${number}.${number}Z`;\n        type DateTimeFormat = `${DateFormat}T${TimeFormat}`;\n        type ZonedDateTimeFormat = `${DateFormat}T${TimeFormat}${Offset}[${string}]`;\n        type YearMonthFormat = `${number}-${number}`;\n        type MonthDayFormat = `--${number}-${number}`;\n        type DurationFormat = `${'' | '-'}P${string}`;\n        interface Format {\n            'YYYY-MM-DD': DateFormat;\n            'hh:mm:ss.sss': TimeFormat;\n            'YYYY-MM-DDThh:mm-ss.sssZ': InstantFormat;\n            'YYYY-MM-DDThh:mm-ss.sss': DateTimeFormat;\n            'YYYY-MM-DDThh:mm-ss.sss+00:00[TimeZoneName]': ZonedDateTimeFormat;\n            'YYYY-MM': YearMonthFormat;\n            '--MM-DD': MonthDayFormat;\n            'P(n)Y(n)M(n)DT(n)H(n)M(n)S': DurationFormat;\n        }\n        /**\n         * An `Iso.Instant` is a single point in time (called \"exact time\"), with a precision in milliseconds. No time zone is present. As such `Iso.Instant` has no concept of days, months or even hours.\n         *\n         * For convenience of interoperability, instants are represented as an ISO8601 string in Zulu time (UTC). The format looks like `1970-01-01T00:00:00.000Z`.\n         *\n         * If you have a legacy Date instance, you can use its toISOString() method to convert to an `Iso.Instant`.\n         *\n         * Since `Iso.Instant` doesn't contain any information about time zones, a `Iso.TimeZone` is needed in order to convert it into a `Iso.DateTime` (and from there into any of the other `Iso` types.)\n         *\n         * Like Unix time, Instant ignores leap seconds.\n         */\n        export type Instant = Format['YYYY-MM-DDThh:mm-ss.sssZ'] & string;\n        /**\n         * An `Iso.ZonedDateTime` is a timezone-aware date/time type that represents a real event that has happened (or will happen) at a particular instant from the perspective of a particular region on Earth. As the broadest `Iso` type, `Iso.ZonedDateTime` can be considered a combination of a `Iso.TimeZone`, `Iso.Instant`, and `Iso.DateTime`.\n         *\n         * As the only `Iso` type that persists a time zone, `Iso.ZonedDateTime` is optimized for use cases that require a time zone:\n         *\n         * - Arithmetic automatically adjusts for Daylight Saving Time, using the rules defined in [RFC 5545 (iCalendar)](https://tools.ietf.org/html/rfc5545) and adopted in other libraries like moment.js.\n         * - Creating derived values (e.g. change time to 2:30AM) can avoid worrying that the result will be invalid due to the time zone's DST rules.\n         * - Functions are available to easily measure attributes like \"length of day\" or \"starting time of day\" which may not be the same on all days in all time zones due to DST transitions or political changes to the definitions of time zones.\n         * - It's easy to flip back and forth between a human-readable representation (like `Iso.DateTime`) and the UTC timeline (like `Iso.Instant`) without having to do any work to keep the two in sync.\n         * - A date/time, an offset, and a time zone are represented in a single string that can be sorted alphabetically by the exact time they happened. This behavior is also helpful for developers who are not sure which of those components will be needed by later readers of this data.\n         * - Multiple time-zone-sensitive operations can be performed in a chain without having to repeatedly provide the same time zone.\n         *\n         * An `Iso.ZonedDateTime` can be losslessly converted into every other `Iso` type except `Iso.Duration`. `Iso.Instant`, `Iso.DateTime`, `Iso.Date`, `Iso.Time`, `Iso.YearMonth`, and `Iso.MonthDay` all carry less information and can be used when complete information is not required.\n         *\n         * The `Iso.ZonedDateTime` functions are a superset of `Iso.DateTime` functions, which makes it easy to port code back and forth between the two types as needed. Because `Iso.DateTime` is not aware of time zones, in use cases where the time zone is known it's recommended to use `Iso.ZonedDateTime` which will automatically adjust for DST and can convert easily to `Iso.Instant` without having to re-specify the time zone.\n         */\n        export type ZonedDateTime = Format['YYYY-MM-DDThh:mm-ss.sss+00:00[TimeZoneName]'] & string;\n        /**\n         * An `Iso.Date` represents a calendar date. \"Calendar date\" refers to the concept of a date as expressed in everyday usage, independent of any time zone. For example, it could be used to represent an event on a calendar which happens during the whole day no matter which time zone it's happening in.\n         *\n         * `Iso.Date` refers to the whole of a specific day; if you need to refer to a specific time on that day, use `Iso.DateTime`. An `Iso.Date` can be converted into a `Iso.ZonedDateTime` by combining it with a `Iso.Time` and `Iso.TimeZone` using the `toZonedDateTime()` function. It can also be combined with a `Iso.Time` to yield a \"zoneless\" `Iso.DateTime` using the `toDateTime()` method.\n         *\n         * `Iso.YearMonth` and `Iso.MonthDay` carry less information than `Iso.Date` and should be used when complete information is not required.\n         */\n        export type Date = Format['YYYY-MM-DD'] & string;\n        /**\n         * An `Iso.Time` represents a wall-clock time, with a precision in milliseconds, and without any time zone. \"Wall-clock time\" refers to the concept of a time as expressed in everyday usage \u2014 the time that you read off the clock on the wall. For example, it could be used to represent an event that happens daily at a certain time, no matter what time zone.\n         *\n         * `Iso.Time` refers to a time with no associated calendar date; if you need to refer to a specific time on a specific day, use `Iso.DateTime`. A `Iso.Time` can be converted into a `Iso.ZonedDateTime` by combining it with a `Iso.Date` and `Iso.TimeZone` using the `toZonedDateTime()` function. It can also be combined with a `Iso.Date` to yield a \"zoneless\" `Iso.DateTime` using the `toDateTime()` function.\n         */\n        export type Time = Format['hh:mm:ss.sss'] & string;\n        /**\n         * An `Iso.DateTime` represents a calendar date and wall-clock time, with a precision in milliseconds, and without any time zone.\n         *\n         * For use cases that require a time zone, especially using arithmetic or other derived values, consider using `Iso.ZonedDateTime` instead because that type automatically adjusts for Daylight Saving Time. A `Iso.DateTime` can be converted to a `Iso.ZonedDateTime` using a `Iso.TimeZone`.\n         *\n         * `Iso.Date`, `Iso.Time`, `Iso.YearMonth`, and `Iso.MonthDay` all carry less information and should be used when complete information is not required.\n         *\n         * A `Iso.DateTime` can be converted into any of the types mentioned above using conversion methods like `toZonedDateTime` or `toDate`.\n         *\n         * Because `Iso.DateTime` does not represent an exact point in time, most date/time use cases are better handled using exact time types like `Iso.ZonedDateTime` and `Iso.Instant`. But there are cases where `Iso.DateTime` is the correct type to use:\n         *\n         * - Representing timezone-specific events where the time zone is not stored together with the date/time data. In this case, `Iso.DateTime` is an intermediate step before converting to/from `Iso.ZonedDateTime` or `Iso.Instant` using the separate time zone. Examples:\n         *    - When the time zone is stored separately in a separate database column or a per-user setting.\n         *    - Implicit time zones, e.g. stock exchange data that is always `America/New_York`\n         *    - Interacting with poorly-designed legacy systems that record data in the server's non-UTC time zone.\n         * - Passing data to/from a component that is unaware of time zones, e.g. a UI date/time picker.\n         * - Modeling events that happen at the same local time in every time zone. For example, the British Commonwealth observes a [two minute silence](https://en.wikipedia.org/wiki/Two-minute_silence) every November 11th at 11:00AM in local time.\n         * - When time zone is irrelevant, e.g. a sleep tracking device that only cares about the local time you went to sleep and woke up, regardless of where in the world you are.\n         * - Parsing local time from ISO 8601 strings like `2020-04-09T16:08-08:00` that have a numeric offset without an IANA time zone like `America/Los_Angeles`. These strings can also be parsed by `Iso.Instant`, but to parse the local date and time then `dateTimeFns.from` is required.\n         * - Performing arithmetic that deliberately ignores DST. Example: in a day-planner UI, the visual height of a meeting may be the same even if DST skips or repeats an hour.\n         * To learn more about time zones and DST best practices, visit [Time Zones and Resolving Ambiguity](https://iso-fns.org/docs/timezones-and-ambiguity).\n         */\n        export type DateTime = Format['YYYY-MM-DDThh:mm-ss.sss'] & string;\n        /**\n         * A `Iso.YearMonth` represents a particular month on the calendar. For example, it could be used to represent a particular instance of a monthly recurring event, like \"the June 2019 meeting\".\n         *\n         * `Iso.YearMonth` refers to the whole of a specific month; if you need to refer to a calendar event on a certain day, use `Iso.Date` or even `Iso.DateTime`. A `Iso.YearMonth` can be converted into a `Iso.Date` by combining it with a day of the month, using the `toDate()` function.\n         */\n        export type YearMonth = Format['YYYY-MM'] & string;\n        /**\n         * A `Iso.MonthDay` represents a particular day on the calendar, but without a year. For example, it could be used to represent a yearly recurring event, like \"Bastille Day is on the 14th of July.\"\n         *\n         * If you need to refer to a certain instance of a calendar event, in a particular year, use `Iso.Date` or even `Iso.DateTime`. A `Iso.MonthDay` can be converted into a `Iso.Date` by combining it with a year, using the `toDate()` method.\n         */\n        export type MonthDay = Format['--MM-DD'] & string;\n        /**\n         * A `Iso.Duration` represents a duration of time which can be used in date/time arithmetic.\n         *\n         * `Iso.Duration` can be constructed directly or returned from `durationFns.from()`. It can also be obtained from the `since()` function of any other `Iso` type that supports arithmetic, and is used in those types' `add()` and `subtract()` functions.\n         *\n         * An `Iso.Duration` is a string according to the ISO 8601 notation for durations. The examples in this page use this notation extensively.\n         *\n         * Briefly, the ISO 8601 notation consists of a P character, followed by years, months, weeks, and days, followed by a T character, followed by hours, minutes, and seconds with a decimal part, each with a single-letter suffix that indicates the unit. Any zero components may be omitted. For more detailed information, see the ISO 8601 standard or the [Wikipedia page](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n         *\n         * | ISO 8601 | Meaning |\n         * |:--|:--|\n         * | P1Y1M1DT1H1M1.1S | One year, one month, one day, one hour, one minute, one second, and 100 milliseconds |\n         * | P40D | Forty days |\n         * | P1Y1D | A year and a day |\n         * | P3DT4H59M | Three days, four hours and 59 minutes |\n         * | PT2H30M | Two and a half hours |\n         * | P1M | One month |\n         * | PT1M | One minute |\n         * | PT0.021S | 21 milliseconds  |\n         * | PT0S | Zero |\n         * | P0D | Zero |\n         *\n         * :::note\n         *\n         * According to the ISO 8601-1 standard, weeks are not allowed to appear together with any other units, and durations can only be positive. As extensions to the standard, ISO 8601-2 allows a sign character at the start of the string, and allows combining weeks with other units. If you intend to use a string such as P3W1D, +P1M, or -P1M for interoperability, note that other programs may not accept it.\n         *\n         * :::\n         */\n        export type Duration = Format['P(n)Y(n)M(n)DT(n)H(n)M(n)S'] & string;\n        export {};\n    }\n}\ndeclare module \"index\" {\n    export * from './fns';\n    export * from \"iso-types\";\n}\ndeclare module \"date.test\" { }\ndeclare module \"regex\" {\n    export const offset: RegExp;\n    export const instant: RegExp;\n    export const datetime: RegExp;\n    export const time: RegExp;\n    export const yearmonth: RegExp;\n    export const monthday: RegExp;\n    export const duration: RegExp;\n}\ndeclare module \"ecmascript\" {\n    import { Iso } from \"iso-types\";\n    export type TemporalRoundingMode = 'halfExpand' | 'ceil' | 'trunc' | 'floor';\n    export type TemporalDisambiguation = 'compatible' | 'earlier' | 'later' | 'reject';\n    export type TemporalOverflow = 'constrain' | 'reject';\n    export type TemporalOffset = 'prefer' | 'ignore' | 'reject' | 'use';\n    export type TemporalSingularUnit = 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\n    export type TemporalPluralUnit = 'years' | 'months' | 'weeks' | 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds';\n    export interface Chain<T> {\n        value(): T;\n    }\n    export function buildChain<T>(value: T): {\n        value(): T;\n    };\n    type CalendarDate = Iso.Date | Iso.DateTime | Iso.ZonedDateTime | Iso.YearMonth | Iso.MonthDay;\n    type Options = Record<string | number | symbol, unknown>;\n    export function IsObject<T>(value: T): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\n    export function ToNumber(value: unknown): number;\n    export function ToString(value: unknown): string;\n    export function ToIntegerThrowOnInfinity(value: unknown): number;\n    export function ToPositiveInteger(valueParam: unknown, property?: string): number;\n    export function GetTimeZoneAbbreviation(timeZone: string, epochMilliseconds: number): any;\n    export function GetTimeZoneName(timeZone: string, epochMilliseconds: number): any;\n    export function IsTemporalInstant(item: unknown): item is Iso.Instant;\n    export function IsTemporalTimeZone(item: unknown): item is string;\n    export function IsTemporalDuration(item: unknown): item is Iso.Duration;\n    export function AssertIsDuration(item: unknown): asserts item is Iso.Duration;\n    export function IsTemporalDate(item: unknown): item is Iso.Date;\n    export function IsTemporalTime(item: unknown): item is Iso.Time;\n    export function IsTemporalDateTime(item: unknown): item is Iso.DateTime;\n    export function IsTemporalYearMonth(item: unknown): item is Iso.YearMonth;\n    export function IsTemporalMonthDay(item: unknown): item is Iso.MonthDay;\n    export function IsTemporalZonedDateTime(item: unknown): item is Iso.ZonedDateTime;\n    export function ParseTemporalZonedDateTimeString(isoString: string): {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n        ianaName: string;\n        offset: string | undefined;\n        z: boolean;\n    };\n    export function ParseTemporalDateTimeString(isoString: string): {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n        ianaName: string;\n        offset: string | undefined;\n        z: boolean;\n    };\n    export function ParseTemporalDateString(isoString: string): {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n        ianaName: string;\n        offset: string | undefined;\n        z: boolean;\n    };\n    export function ParseTemporalTimeString(isoString: string): {\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    };\n    export function ParseTemporalYearMonthString(isoString: string): {\n        year: number;\n        month: number;\n        referenceISODay: number | undefined;\n    };\n    export function ParseTemporalMonthDayString(isoString: string): {\n        month: number;\n        day: number;\n        referenceISOYear: number | undefined;\n    };\n    export function ParseTemporalDurationString(isoString: string): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    };\n    export function ParseTemporalInstant(isoString: string): number;\n    export function RegulateISODate(year: number, month: number, day: number, overflow: TemporalOverflow): {\n        year: number;\n        month: number;\n        day: number;\n    };\n    export function RegulateTime(hour: number, minute: number, second: number, millisecond: number, overflow: TemporalOverflow): {\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    };\n    export function RegulateISOYearMonth(year: number, month: number, overflow: TemporalOverflow): {\n        year: number;\n        month: number;\n    };\n    export function ToLimitedTemporalDuration(item: Iso.Duration | Partial<DurationSlots>, disallowedProperties?: TemporalPluralUnit[]): DurationSlots;\n    export function ToTemporalOverflow(options: Options): \"constrain\" | \"reject\";\n    export function ToTemporalDisambiguation(options: Options): \"reject\" | \"compatible\" | \"earlier\" | \"later\";\n    export function ToTemporalRoundingMode(options: Options, fallback: TemporalRoundingMode): \"halfExpand\" | \"ceil\" | \"floor\" | \"trunc\";\n    export function NegateTemporalRoundingMode(roundingMode: TemporalRoundingMode): \"halfExpand\" | \"ceil\" | \"floor\" | \"trunc\";\n    export function ToTemporalOffset(options: Options, fallback: TemporalOffset): \"reject\" | \"prefer\" | \"ignore\" | \"use\";\n    export function ToShowTimeZoneNameOption(options: Options): \"auto\" | \"never\";\n    export function ToShowOffsetOption(options: Options): \"auto\" | \"never\";\n    export function ToTemporalRoundingIncrement(options: Options, dividend: number | undefined, inclusive: boolean): number;\n    export function ToTemporalDateTimeRoundingIncrement(options: Options, smallestUnit: TemporalSingularUnit): number;\n    export function ToSecondsStringPrecision(options: Options): {\n        precision: 0 | 1 | 2 | 3 | 'auto' | 'minute';\n        unit: string;\n        increment: number;\n    };\n    export function ToLargestTemporalUnit(options: Options, fallback: TemporalSingularUnit | TemporalPluralUnit | 'auto' | undefined, disallowedStrings?: TemporalSingularUnit[], autoValue?: any): TemporalSingularUnit | 'auto';\n    export function ToSmallestTemporalUnit(options: Options, fallback: TemporalSingularUnit | TemporalPluralUnit | undefined, disallowedStrings?: TemporalSingularUnit[]): TemporalSingularUnit;\n    export function ToTemporalDurationTotalUnit(options: Options): TemporalSingularUnit;\n    export function ToRelativeTemporalObject(options: Options): Iso.ZonedDateTime | Iso.DateTime | undefined;\n    export function ValidateTemporalUnitRange(largestUnit: TemporalSingularUnit, smallestUnit: TemporalSingularUnit): void;\n    export function DefaultTemporalLargestUnit(years: number, months: number, weeks: number, days: number, hours: number, minutes: number, seconds: number, milliseconds: number): TemporalSingularUnit;\n    export function LargerOfTwoTemporalUnits(unit1: TemporalSingularUnit, unit2: TemporalSingularUnit): TemporalSingularUnit;\n    export function ToPartialRecord(bag: {\n        [key: string]: any;\n    }, fields: string[], callerCast?: (value: unknown) => unknown): Record<string, any> | false;\n    export function PrepareTemporalFields(bag: {\n        [key: string]: any;\n    }, fields: [string, (number | undefined)?][]): {\n        [key: string]: any;\n    };\n    export function ToTemporalDateFields(bag: {\n        [key: string]: any;\n    }): DateSlots;\n    export function ToTemporalDateTimeFields(bag: {\n        [key: string]: any;\n    }): {\n        day: number;\n        hour: number;\n        millisecond: number;\n        minute: number;\n        month: number;\n        second: number;\n        year: number;\n    };\n    export function ToTemporalMonthDayFields(bag: {\n        [key: string]: any;\n    }): {\n        day: number;\n        month: number;\n        year: number;\n    };\n    export function ToTemporalTimeRecord(bag: {\n        [key: string]: any;\n    }): TimeSlots;\n    export function ToTemporalYearMonthFields(bag: {\n        [key: string]: any;\n    }): {\n        month: number;\n        year: number;\n    };\n    export function ToTemporalZonedDateTimeFields(bag: {\n        [key: string]: any;\n    }): {\n        day: number;\n        hour: number;\n        millisecond: number;\n        minute: number;\n        month: number;\n        second: number;\n        year: number;\n        offset: string;\n        timeZone: string;\n    };\n    export function ToTemporalDate(item: any, options?: any): Iso.Date;\n    export function InterpretTemporalDateTimeFields(fields: DateTimeSlots, options: Options): {\n        year: number;\n        month: number;\n        day: number;\n        hour: any;\n        minute: any;\n        second: any;\n        millisecond: any;\n    };\n    export function ToTemporalDateTime(item: any, options?: any): Iso.DateTime;\n    export function ToTemporalDuration(item: any): Iso.Duration;\n    export function ToTemporalInstant(item: string): Iso.Instant;\n    export function ToTemporalMonthDay(item: any, options?: any): Iso.MonthDay;\n    export function ToTemporalTime(item: any, overflow?: TemporalOverflow): Iso.Time;\n    export function ToTemporalYearMonth(item: any, options?: any): Iso.YearMonth;\n    export function InterpretISODateTimeOffset(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, offsetBehaviour: string, offsetMs: number, timeZone: string, disambiguation: TemporalDisambiguation, offsetOpt: TemporalOffset): number;\n    export function ToTemporalZonedDateTime(item: any, options?: any): Iso.ZonedDateTime;\n    export function CreateTemporalInstant(epochMilliseconds: number): Iso.Instant;\n    export function CreateTemporalDuration(years: number, months: number, weeks: number, days: number, hours: number, minutes: number, seconds: number, milliseconds: number): Iso.Duration;\n    export function CreateTemporalDate(year: number, month: number, day: number): Iso.Date;\n    export function CreateTemporalTime(hour: number, minute: number, second: number, millisecond: number): Iso.Time;\n    export function CreateTemporalDateTime(year: number, month: number, day: number, h: number, min: number, s: number, ms: number): Iso.DateTime;\n    export function CreateTemporalMonthDay(month: number, day: number, referenceISOYear?: number): Iso.MonthDay;\n    export function CreateTemporalYearMonth(year: number, month: number, referenceISODay?: number): Iso.YearMonth;\n    export function CreateTemporalZonedDateTime(epochMilliseconds: number, timeZone: string): Iso.ZonedDateTime;\n    export function CalendarMergeFields(fields: {\n        [key: string]: any;\n    }, additionalFields: {\n        [key: string]: any;\n    }): {\n        [key: string]: any;\n    };\n    export function CalendarDateAdd(date: CalendarDate | undefined, duration: Iso.Duration | Partial<DurationSlots>, options: Options | undefined): Iso.Date;\n    export function CalendarDateUntil(date: CalendarDate | undefined, otherDate: CalendarDate, options: Options): Iso.Duration;\n    export function CalendarYear(dateLike: CalendarDate): number;\n    export function CalendarMonth(dateLike: CalendarDate): number;\n    export function CalendarDay(dateLike: CalendarDate): number;\n    export function CalendarDayOfWeek(dateLike: CalendarDate): number;\n    export function CalendarDayOfYear(dateLike: CalendarDate): number;\n    export function CalendarWeekOfYear(dateLike: CalendarDate): number;\n    export function CalendarDaysInWeek(dateLike: CalendarDate): number;\n    export function CalendarDaysInMonth(dateLike: CalendarDate): number;\n    export function CalendarDaysInYear(dateLike: CalendarDate): 366 | 365;\n    export function CalendarMonthsInYear(): number;\n    export function CalendarInLeapYear(dateLike: CalendarDate): boolean;\n    export function DateFromFields(fields: DateSlots, options?: any): Iso.Date;\n    export function YearMonthFromFields(fields: YearMonthSlots, options?: any): Iso.YearMonth;\n    export function MonthDayFromFields(fields: MonthDaySlots, options?: any): Iso.MonthDay;\n    export function ToTemporalTimeZone(temporalTimeZoneLike: string): string;\n    export function TimeZoneEquals(one: string, two: string): boolean;\n    export function TemporalDateTimeToDate(dateTime: Iso.DateTime): Iso.Date;\n    export function TemporalDateTimeToTime(dateTime: Iso.DateTime): Iso.Time;\n    export function GetOffsetMillisecondsFor(timeZone: string, epochMilliseconds: number): number;\n    export function BuiltinTimeZoneGetOffsetStringFor(timeZone: string, epochMilliseconds: number): string;\n    export function BuiltinTimeZoneGetPlainDateTimeFor(timeZone: string, epochMilliseconds: number): Iso.DateTime;\n    export function BuiltinTimeZoneGetInstantFor(timeZone: string, dateTime: Iso.DateTime, disambiguation: TemporalDisambiguation): number;\n    export function ISOYearString(year: number): string;\n    export function ISODateTimePartString(part: number): string;\n    export function FormatSecondsStringPart(second: number, millisecond: number): string;\n    export function ParseOffsetString(string: string): number | null;\n    export function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier: any): string;\n    export function GetIANATimeZoneOffsetMilliseconds(epochMilliseconds: number, timeZone: string): number;\n    export function GetEpochFromISOParts(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): number | null;\n    export function GetIANATimeZoneDateTimeParts(epochMilliseconds: number, timeZone: string): DateTimeSlots;\n    export function GetIANATimeZoneNextTransition(epochMilliseconds: number, timeZone: string): number | null;\n    export function GetIANATimeZonePreviousTransition(epochMilliseconds: number, timeZone: string): number | null;\n    export function GetFormatterParts(timeZone: string, epochMilliseconds: number): {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n    };\n    export function GetIANATimeZoneEpochValue(timeZone: string, year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): number[];\n    export function LeapYear(year: number): boolean;\n    export function ISODaysInMonth(year: number, month: number): number;\n    export function DayOfWeek(year: number, month: number, day: number): number;\n    export function DayOfYear(year: number, month: number, day: number): number;\n    export function WeekOfYear(year: number, month: number, day: number): number;\n    export function DurationSign(y: number, mon: number, w: number, d: number, h: number, min: number, s: number, ms: number): number;\n    export function TotalDurationMilliseconds(days: number, hours: number, minutes: number, seconds: number, milliseconds: number, offsetShift: number): number;\n    export function BalanceDuration(days: number, hours: number, minutes: number, seconds: number, milliseconds: number, largestUnit: TemporalSingularUnit, relativeTo?: CalendarDate | undefined): {\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    };\n    export function UnbalanceDurationRelative(years: number, months: number, weeks: number, days: number, largestUnit: TemporalSingularUnit, relativeTo: CalendarDate | undefined): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n    };\n    export function BalanceDurationRelative(years: number, months: number, weeks: number, days: number, largestUnit: TemporalSingularUnit, relativeTo: CalendarDate | undefined): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n    };\n    export function CalculateOffsetShift(relativeTo: CalendarDate | undefined, y: number, mon: number, w: number, d: number, h: number, min: number, s: number, ms: number): number;\n    export function CreateNegatedTemporalDuration(duration: Iso.Duration): Iso.Duration;\n    export function ConstrainToRange(value: number, min: number, max: number): number;\n    export function RejectToRange(value: number, min: number, max: number): void;\n    export function RejectTime(hour: number, minute: number, second: number, millisecond: number): void;\n    export function ValidateEpochMilliseconds(epochMilliseconds: number): void;\n    export function DifferenceISODate(y1: number, m1: number, d1: number, y2: number, m2: number, d2: number, largestUnit?: 'year' | 'month' | 'week' | 'day'): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n    };\n    export function DifferenceTime(h1: number, min1: number, s1: number, ms1: number, h2: number, min2: number, s2: number, ms2: number): {\n        deltaDays: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    };\n    export function DifferenceInstant(ms1: number, ms2: number, increment: number, unit: 'hour' | 'minute' | 'second' | 'millisecond', roundingMode: TemporalRoundingMode): {\n        seconds: number;\n        milliseconds: number;\n    };\n    export function DifferenceISODateTime(y1: number, mon1: number, d1: number, h1: number, min1: number, s1: number, ms1: number, y2: number, mon2: number, d2: number, h2: number, min2: number, s2: number, ms2: number, largestUnit: TemporalSingularUnit, options?: any): DurationSlots;\n    export function DifferenceZonedDateTime(ms1: number, ms2: number, timeZone: string, largestUnit: TemporalSingularUnit, options?: any): DurationSlots;\n    export function AddISODate(year: number, month: number, day: number, years: number, months: number, weeks: number, days: number, overflow: TemporalOverflow): {\n        year: number;\n        month: number;\n        day: number;\n    };\n    export function AddTime(hour: number, minute: number, second: number, millisecond: number, hours: number, minutes: number, seconds: number, milliseconds: number): {\n        deltaDays: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    };\n    export function AddDuration(y1: number, mon1: number, w1: number, d1: number, h1: number, min1: number, s1: number, ms1: number, y2: number, mon2: number, w2: number, d2: number, h2: number, min2: number, s2: number, ms2: number, relativeTo: Iso.DateTime | Iso.ZonedDateTime | undefined): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    };\n    export function AddInstant(epochMilliseconds: number, h: number, min: number, s: number, ms: number): number;\n    export function AddDateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, years: number, months: number, weeks: number, days: number, hours: number, minutes: number, seconds: number, milliseconds: number, options: Options | undefined): {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    };\n    export function AddZonedDateTime(epochMilliseconds: number, timeZone: string, years: number, months: number, weeks: number, days: number, h: number, min: number, s: number, ms: number, options?: any): number;\n    export function RoundInstant(epochMs: number, increment: number, unit: 'hour' | 'minute' | 'second' | 'millisecond', roundingMode: TemporalRoundingMode): number;\n    export function RoundISODateTime(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, increment: number, unit: 'day' | 'hour' | 'minute' | 'second' | 'millisecond', roundingMode: TemporalRoundingMode, dayLengthMs?: number): DateTimeSlots;\n    export function RoundTime(hour: number, minute: number, second: number, millisecond: number, increment: number, unit: 'day' | 'hour' | 'minute' | 'second' | 'millisecond', roundingMode: TemporalRoundingMode, dayLengthMs?: number): {\n        deltaDays: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    };\n    export function MoveRelativeZonedDateTime(relativeTo: Iso.ZonedDateTime, years: number, months: number, weeks: number, days: number): Iso.ZonedDateTime;\n    export function AdjustRoundedDurationDays(years: number, months: number, weeks: number, days: number, hours: number, minutes: number, seconds: number, milliseconds: number, increment: number, unit: TemporalSingularUnit, roundingMode: TemporalRoundingMode, relativeTo?: CalendarDate): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    };\n    export function RoundDuration(years: number, months: number, weeks: number, days: number, hours: number, minutes: number, seconds: number, milliseconds: number, increment: number, unit: TemporalSingularUnit | undefined, roundingMode: TemporalRoundingMode, relativeTo?: CalendarDate | undefined): {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n        total: number;\n    };\n    export function CompareISODate(y1: number, m1: number, d1: number, y2: number, m2: number, d2: number): number;\n    export function SystemUTCEpochMilliSeconds(): number;\n    export function SystemTimeZone(): string;\n    export function ComparisonResult(value: number): number;\n    export function GetOptionsObject<T>(options: T | undefined): T;\n    export interface InstantSlots {\n        epochMilliseconds: number;\n    }\n    export interface ZonedDateTimeSlots {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n        offset: string;\n        epochMilliseconds: number;\n        timeZone: string;\n    }\n    export interface DateTimeSlots {\n        year: number;\n        month: number;\n        day: number;\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    }\n    export interface DateSlots {\n        year: number;\n        month: number;\n        day: number;\n    }\n    export interface TimeSlots {\n        hour: number;\n        minute: number;\n        second: number;\n        millisecond: number;\n    }\n    export interface YearMonthSlots {\n        year: number;\n        month: number;\n    }\n    export interface MonthDaySlots {\n        month: number;\n        day: number;\n    }\n    export interface DurationSlots {\n        years: number;\n        months: number;\n        weeks: number;\n        days: number;\n        hours: number;\n        minutes: number;\n        seconds: number;\n        milliseconds: number;\n    }\n    export function GetSlots(instant: Iso.Instant): InstantSlots;\n    export function GetSlots(zonedDateTime: Iso.ZonedDateTime): ZonedDateTimeSlots;\n    export function GetSlots(dateTime: Iso.DateTime): DateTimeSlots;\n    export function GetSlots(date: Iso.Date): DateSlots;\n    export function GetSlots(time: Iso.Time): TimeSlots;\n    export function GetSlots(yearMonth: Iso.YearMonth): YearMonthSlots;\n    export function GetSlots(monthDay: Iso.MonthDay): MonthDaySlots;\n    export function GetSlots(duration: Iso.Duration): DurationSlots;\n    export function GetInstantSlots(input: Iso.Instant): InstantSlots;\n    export function GetZonedDateTimeSlots(input: Iso.ZonedDateTime): ZonedDateTimeSlots;\n    export function GetDateTimeSlots(input: Iso.DateTime): DateTimeSlots;\n    export function GetDateSlots(input: Iso.Date): DateSlots;\n    export function GetTimeSlots(input: Iso.Time): TimeSlots;\n    export function GetYearMonthSlots(input: Iso.YearMonth): YearMonthSlots;\n    export function GetMonthDaySlots(input: Iso.MonthDay): MonthDaySlots;\n    export function GetDurationSlots(input: Iso.Duration): DurationSlots;\n}\ndeclare module \"zoneddatetime.test\" { }\ndeclare module \"fns/durationFns\" {\n    import { IDurationChain, IDurationFns } from '../types';\n    import { Iso } from \"iso-types\";\n    export const durationFns: IDurationFns;\n    export function buildDurationChain(duration: Iso.Duration): IDurationChain;\n}\ndeclare module \"fns/instantFns\" {\n    import { IInstantChain, IInstantFns } from '../types';\n    import { Iso } from \"iso-types\";\n    export const instantFns: IInstantFns;\n    export function buildInstantChain(instant: Iso.Instant): IInstantChain;\n}\ndeclare module \"fns/timeFns\" {\n    import { ITimeChain, ITimeFns } from '../types';\n    import { Iso } from \"iso-types\";\n    export const timeFns: ITimeFns;\n    export function buildTimeChain(time: Iso.Time): ITimeChain;\n}\ndeclare module \"fns/yearMonthFns\" {\n    import { IYearMonthFns, IYearMonthChain } from '../types';\n    import { Iso } from \"iso-types\";\n    export const yearMonthFns: IYearMonthFns;\n    export function buildYearMonthChain(yearMonth: Iso.YearMonth): IYearMonthChain;\n}\ndeclare module \"fns/monthDayFns\" {\n    import { IMonthDayFns, IMonthDayChain } from '../types';\n    import { Iso } from \"iso-types\";\n    export const monthDayFns: IMonthDayFns;\n    export function buildMonthDayChain(monthDay: Iso.MonthDay): IMonthDayChain;\n}\ndeclare module \"fns/zonedDateTimeFns\" {\n    import { Iso } from \"iso-types\";\n    import { IZonedDateTimeFns, IZonedDateTimeChain } from '../types';\n    export const zonedDateTimeFns: IZonedDateTimeFns;\n    export function buildZonedDateTimeChain(zonedDateTime: Iso.ZonedDateTime): IZonedDateTimeChain;\n}\ndeclare module \"fns/dateTimeFns\" {\n    import { IDateTimeFns, IDateTimeChain } from '../types';\n    import { Iso } from \"iso-types\";\n    export const dateTimeFns: IDateTimeFns;\n    export function buildDateTimeChain(dateTime: Iso.DateTime): IDateTimeChain;\n}\ndeclare module \"fns/dateFns\" {\n    import { IDateChain, IDateFns } from '../types';\n    import { Iso } from \"iso-types\";\n    export const dateFns: IDateFns;\n    export function buildDateChain(date: Iso.Date): IDateChain;\n}\ndeclare module \"fns/index\" {\n    export { dateFns } from \"fns/dateFns\";\n    export { dateTimeFns } from \"fns/dateTimeFns\";\n    export { durationFns } from \"fns/durationFns\";\n    export { instantFns } from \"fns/instantFns\";\n    export { monthDayFns } from \"fns/monthDayFns\";\n    export { timeFns } from \"fns/timeFns\";\n    export { yearMonthFns } from \"fns/yearMonthFns\";\n    export { zonedDateTimeFns } from \"fns/zonedDateTimeFns\";\n}\ndeclare module \"format/addLeadingZeros\" {\n    export default function addLeadingZeros(number: number, targetLength: number): string;\n}\ndeclare module \"format/types\" {\n    type Era = 0 | 1;\n    type Quarter = 1 | 2 | 3 | 4;\n    export type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n    export type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;\n    type LocaleOrdinalUnit = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year' | 'date' | 'dayOfYear';\n    export type LocalePatternWidth = 'narrow' | 'short' | 'abbreviated' | 'wide' | 'any';\n    export type LocaleDayPeriod = 'am' | 'pm' | 'midnight' | 'noon' | 'morning' | 'afternoon' | 'evening' | 'night';\n    export type LocaleUnit = Era | Quarter | Month | Day | LocaleDayPeriod;\n    export type LocalizeFn<Result extends LocaleUnit | number, ArgCallback extends BuildLocalizeFnArgCallback<Result> | undefined> = (value: ArgCallback extends undefined ? Result : LocalizeUnitIndex<Result>, options?: {\n        width?: LocalePatternWidth;\n        context?: 'formatting' | 'standalone';\n        unit?: LocaleOrdinalUnit;\n    }) => string;\n    type LocalizeEraValues = readonly [string, string];\n    type LocalizeQuarterValues = readonly [string, string, string, string];\n    type LocalizeDayValues = readonly [string, string, string, string, string, string, string];\n    type LocalizeMonthValues = readonly [\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string,\n        string\n    ];\n    export type LocalizeUnitValuesIndex<Values extends LocalizeUnitValues<any>> = Values extends Record<LocaleDayPeriod, string> ? string : Values extends LocalizeEraValues ? Era : Values extends LocalizeQuarterValues ? QuarterIndex : Values extends LocalizeDayValues ? Day : Values extends LocalizeMonthValues ? Month : never;\n    export type LocalizeUnitValues<Unit extends LocaleUnit> = Unit extends LocaleDayPeriod ? Record<LocaleDayPeriod, string> : Unit extends Era ? LocalizeEraValues : Unit extends Quarter ? LocalizeQuarterValues : Unit extends Day ? LocalizeDayValues : Unit extends Month ? LocalizeMonthValues : never;\n    export type LocalizeUnitIndex<Unit extends LocaleUnit | number> = Unit extends LocaleUnit ? LocalizeUnitValuesIndex<LocalizeUnitValues<Unit>> : number;\n    export type QuarterIndex = 0 | 1 | 2 | 3;\n    type BuildLocalizeFnArgCallback<Result extends LocaleUnit | number> = (value: Result) => LocalizeUnitIndex<Result>;\n    export interface Localize {\n        ordinalNumber: LocalizeFn<number, BuildLocalizeFnArgCallback<number> | undefined>;\n        era: LocalizeFn<Era, undefined>;\n        quarter: LocalizeFn<Quarter, BuildLocalizeFnArgCallback<Quarter>>;\n        month: LocalizeFn<Month, undefined>;\n        day: LocalizeFn<Day, undefined>;\n        dayPeriod: LocalizeFn<LocaleDayPeriod, undefined>;\n    }\n    export type FormatLongWidth = 'full' | 'long' | 'medium' | 'short';\n    interface FormatLongFnOptions {\n        width?: FormatLongWidth;\n    }\n    export type FormatLongFn = (options: FormatLongFnOptions) => string;\n    export interface FormatLong {\n        date: FormatLongFn;\n        time: FormatLongFn;\n        dateTime: FormatLongFn;\n    }\n}\ndeclare module \"format/buildFormatLongFn\" {\n    import { FormatLongFn, FormatLongWidth } from \"format/types\";\n    export interface BuildFormatLongFnArgs {\n        formats: {\n            [format in FormatLongWidth]: string;\n        };\n        defaultWidth: FormatLongWidth;\n    }\n    export default function buildFormatLongFn(args: BuildFormatLongFnArgs): FormatLongFn;\n}\ndeclare module \"format/buildLocalizeFunction\" {\n    import { LocalePatternWidth, LocaleUnit, LocalizeFn, LocalizeUnitIndex, LocalizeUnitValues } from \"format/types\";\n    type LocalizePeriodValuesMap<Unit extends LocaleUnit> = {\n        [pattern in LocalePatternWidth]?: LocalizeUnitValues<Unit>;\n    };\n    type BuildLocalizeFnArgCallback<Result extends LocaleUnit | number> = (value: Result) => LocalizeUnitIndex<Result>;\n    type BuildLocalizeFnArgs<Result extends LocaleUnit, ArgCallback extends BuildLocalizeFnArgCallback<Result> | undefined> = {\n        values: LocalizePeriodValuesMap<Result>;\n        defaultWidth: LocalePatternWidth;\n        formattingValues?: LocalizePeriodValuesMap<Result>;\n        defaultFormattingWidth?: LocalePatternWidth;\n    } & (ArgCallback extends undefined ? {\n        argumentCallback?: undefined;\n    } : {\n        argumentCallback: BuildLocalizeFnArgCallback<Result>;\n    });\n    export default function buildLocalizeFn<Result extends LocaleUnit, ArgCallback extends BuildLocalizeFnArgCallback<Result> | undefined>(args: BuildLocalizeFnArgs<Result, ArgCallback>): LocalizeFn<Result, ArgCallback>;\n}\ndeclare module \"format/en-us-locale\" {\n    import type { Localize } from \"format/types\";\n    import type { FormatLong } from \"format/types\";\n    const _default: {\n        formatLong: FormatLong;\n        code: string;\n        localize: Localize;\n        options: {\n            weekStartsOn: number;\n            firstWeekContainsDate: number;\n        };\n    };\n    export default _default;\n}\ndeclare module \"format/format.test\" { }\ndeclare module \"format/lightFormatters\" {\n    const formatters: {\n        y(date: {\n            year: number;\n        }, token: string): string;\n        M(date: {\n            month: number;\n        }, token: string): string;\n        d(date: {\n            day: number;\n        }, token: string): string;\n        a(date: {\n            hour: number;\n        }, token: string): string;\n        h(date: {\n            hour: number;\n        }, token: string): string;\n        H(date: {\n            hour: number;\n        }, token: string): string;\n        m(date: {\n            minute: number;\n        }, token: string): string;\n        s(date: {\n            second: number;\n        }, token: string): string;\n        S(date: {\n            millisecond: number;\n        }, token: string): string;\n    };\n    export default formatters;\n}\ndeclare module \"format/formatters\" {\n    import { Localize } from \"format/types\";\n    var formatters: {\n        G(date: {\n            year: number;\n        }, token: string, localize: Localize): string;\n        y(date: {\n            year: number;\n        }, token: string, localize: Localize): string;\n        u(date: {\n            year: number;\n        }, token: string): string;\n        Q(date: {\n            month: number;\n        }, token: string, localize: Localize): string;\n        M(date: {\n            month: number;\n        }, token: string, localize: Localize): string;\n        I(date: {\n            year: number;\n            month: number;\n            day: number;\n        }, token: string, localize: Localize): string;\n        d(date: {\n            day: number;\n        }, token: string, localize: Localize): string;\n        E(date: {\n            year: number;\n            month: number;\n            day: number;\n        }, token: string, localize: Localize): string;\n        i(date: {\n            year: number;\n            month: number;\n            day: number;\n        }, token: string, localize: Localize): string;\n        a(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        b(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        B(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        h(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        H(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        K(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        k(date: {\n            hour: number;\n        }, token: string, localize: Localize): string;\n        m(date: {\n            minute: number;\n        }, token: string, localize: Localize): string;\n        s(date: {\n            second: number;\n        }, token: string, localize: Localize): string;\n        S(date: {\n            millisecond: number;\n        }, token: string): string;\n        X(date: {\n            offset: string;\n        }, token: string): string;\n        x(date: {\n            offset: string;\n        }, token: string): string;\n        O(date: {\n            offset: string;\n        }, token: string): string;\n        z(date: {\n            timeZone: string;\n            epochMilliseconds: number;\n        }, token: string): any;\n    };\n    export default formatters;\n}\ndeclare module \"format/longFormatters\" {\n    import { FormatLong } from \"format/types\";\n    function timeLongFormatter(pattern: string, formatLong: FormatLong): string;\n    function dateTimeLongFormatter(pattern: string, formatLong: FormatLong): string;\n    const longFormatters: {\n        p: typeof timeLongFormatter;\n        P: typeof dateTimeLongFormatter;\n    };\n    export default longFormatters;\n}\ndeclare module \"format/format\" {\n    export default function format(date: {\n        year?: number;\n        month?: number;\n        day?: number;\n        hour?: number;\n        minute?: number;\n        second?: number;\n        millisecond?: number;\n        offset?: string;\n        timeZone?: string;\n        epochMilliseconds?: number;\n    }, formatStr: string): string;\n}\ndeclare module \"format/index\" {\n    import format from \"format/format\";\n    export default format;\n}\ndeclare module \"types/IDurationFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    export interface IDurationFns {\n        fromNumbers(years?: number, months?: number, weeks?: number, days?: number, hours?: number, minute?: number, seconds?: number, milliseconds?: number): Iso.Duration;\n        isValid(duration: unknown): duration is Iso.Duration;\n        assertIsValid(duration: unknown): asserts duration is Iso.Duration;\n        getYears(duration: Iso.Duration): number;\n        getMonths(duration: Iso.Duration): number;\n        getWeeks(duration: Iso.Duration): number;\n        getDays(duration: Iso.Duration): number;\n        getHours(duration: Iso.Duration): number;\n        getMinutes(duration: Iso.Duration): number;\n        getSeconds(duration: Iso.Duration): number;\n        getMilliseconds(duration: Iso.Duration): number;\n        getSign(duration: Iso.Duration): number;\n        isBlank(duration: Iso.Duration): boolean;\n        with(duration: Iso.Duration, durationLike: {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): Iso.Duration;\n        negated(duration: Iso.Duration): Iso.Duration;\n        abs(duration: Iso.Duration): Iso.Duration;\n        add(duration: Iso.Duration, other: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            relativeTo: Iso.DateTime | Iso.ZonedDateTime;\n        }): Iso.Duration;\n        subtract(duration: Iso.Duration, other: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            relativeTo: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): Iso.Duration;\n        round(duration: Iso.Duration, options: {\n            largestUnit?: ES.TemporalSingularUnit | 'auto';\n            smallestUnit: ES.TemporalSingularUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n            relativeTo?: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): Iso.Duration;\n        total(duration: Iso.Duration, options: {\n            unit: ES.TemporalSingularUnit;\n            relativeTo?: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): number;\n        getFields(duration: Iso.Duration): ES.DurationSlots;\n        from(item: any): Iso.Duration;\n        compare(one: Iso.Duration, two: Iso.Duration, options?: {\n            relativeTo: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): number;\n        chain(duration: Iso.Duration): IDurationChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IDurationChain extends ES.Chain<Iso.Duration> {\n        getYears(): ES.Chain<number>;\n        getMonths(): ES.Chain<number>;\n        getWeeks(): ES.Chain<number>;\n        getDays(): ES.Chain<number>;\n        getHours(): ES.Chain<number>;\n        getMinutes(): ES.Chain<number>;\n        getSeconds(): ES.Chain<number>;\n        getMilliseconds(): ES.Chain<number>;\n        getSign(): ES.Chain<number>;\n        isBlank(): ES.Chain<boolean>;\n        with(durationLike: {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): IDurationChain;\n        negated(): IDurationChain;\n        abs(): IDurationChain;\n        add(other: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            relativeTo: Iso.DateTime | Iso.ZonedDateTime;\n        }): IDurationChain;\n        subtract(other: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            relativeTo: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): IDurationChain;\n        round(options: {\n            largestUnit?: ES.TemporalSingularUnit | 'auto';\n            smallestUnit: ES.TemporalSingularUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n            relativeTo?: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): IDurationChain;\n        total(options: {\n            unit: ES.TemporalSingularUnit;\n            relativeTo?: Iso.DateTime | Iso.ZonedDateTime | Iso.Date;\n        }): ES.Chain<number>;\n        getFields(): ES.Chain<ES.DurationSlots>;\n    }\n}\ndeclare module \"types/IInstantFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    import { IZonedDateTimeChain } from \"types/IZonedDateTimeFns\";\n    export interface IInstantFns {\n        /**\n         *\n         * This method gets the current exact system time, without regard to time zone. This is a good way to get a timestamp for an event, for example. It works like the old-style JavaScript Date.now().\n         *\n         * @returns an `Iso.Instant` string representing the current system time.\n         */\n        now(): Iso.Instant;\n        fromEpochMilliseconds(epochMilliseconds: number): Iso.Instant;\n        isValid(instant: unknown): instant is Iso.Instant;\n        assertIsValid(instant: unknown): asserts instant is Iso.Instant;\n        getEpochSeconds(instant: Iso.Instant): number;\n        getEpochMilliseconds(instant: Iso.Instant): number;\n        /**\n         * Here is a comment!\n         * @param instant\n         * @param temporalDurationLike\n         */\n        add(instant: Iso.Instant, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): Iso.Instant;\n        subtract(instant: Iso.Instant, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): Iso.Instant;\n        until(from: Iso.Instant, until: Iso.Instant, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(to: Iso.Instant, since: Iso.Instant, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        round(instant: Iso.Instant, options: {\n            smallestUnit?: ES.TemporalSingularUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Instant;\n        equals(instant: Iso.Instant, other: Iso.Instant): boolean;\n        isBefore(instant: Iso.Instant, other: Iso.Instant): boolean;\n        isAfter(instant: Iso.Instant, other: Iso.Instant): boolean;\n        toZonedDateTime(instant: Iso.Instant, timeZone: string): Iso.ZonedDateTime;\n        toJsDate(instant: Iso.Instant): Date;\n        fromEpochSeconds(epochSeconds: number): Iso.Instant;\n        from(item: any): Iso.Instant;\n        compare(one: Iso.Instant, two: Iso.Instant): number;\n        chain(instant: Iso.Instant): IInstantChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IInstantChain extends ES.Chain<Iso.Instant> {\n        getEpochSeconds(): ES.Chain<number>;\n        getEpochMilliseconds(): ES.Chain<number>;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): IInstantChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }): IInstantChain;\n        until(until: Iso.Instant, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(since: Iso.Instant, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        round(options: {\n            smallestUnit?: ES.TemporalSingularUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IInstantChain;\n        equals(other: Iso.Instant): ES.Chain<boolean>;\n        isBefore(other: Iso.Instant): ES.Chain<boolean>;\n        isAfter(other: Iso.Instant): ES.Chain<boolean>;\n        toZonedDateTime(timeZone: string): IZonedDateTimeChain;\n        toJsDate(): ES.Chain<Date>;\n    }\n}\ndeclare module \"types/ITimeFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    import { IZonedDateTimeChain } from \"types/IZonedDateTimeFns\";\n    import { IDateTimeChain } from \"types/IDateTimeFns\";\n    export interface ITimeFns {\n        /**\n         * This method gets the current wall-clock time according to the system settings. Optionally a time zone can be given in which the time is computed, instead of the current system time zone.\n         *\n         * @param timeZone The time zone to get the current date and time in as a string. If not given, the current system time zone will be used.\n         * @returns an `Iso.Time` string representing the current system time.\n         */\n        now(timeZone?: string): Iso.Time;\n        fromNumbers(hour?: number, minute?: number, second?: number, millisecond?: number): Iso.Time;\n        isValid(time: unknown): time is Iso.Time;\n        assertIsValid(time: unknown): asserts time is Iso.Time;\n        getHour(time: Iso.Time): number;\n        getMinute(time: Iso.Time): number;\n        getSecond(time: Iso.Time): number;\n        getMillisecond(time: Iso.Time): number;\n        with(time: Iso.Time, timeLike: {\n            hour?: number;\n            minute?: number;\n            second?: number;\n            millisecond?: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.Time;\n        add(time: Iso.Time, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.Time;\n        subtract(time: Iso.Time, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.Time;\n        until(time: Iso.Time, other: Iso.Time, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(time: Iso.Time, other: Iso.Time, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        round(time: Iso.Time, options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Time;\n        equals(time: Iso.Time, other: Iso.Time): boolean;\n        toDateTime(time: Iso.Time, date: Iso.Date): Iso.DateTime;\n        toZonedDateTime(time: Iso.Time, item: {\n            date: Iso.Date;\n            timeZone: string;\n        }): Iso.ZonedDateTime;\n        getFields(time: Iso.Time): ES.TimeSlots;\n        from(item: any, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.Time;\n        compare(one: Iso.Time, two: Iso.Time): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | AM, PM                          | a..aa   | AM, PM                            |       |\n         * |                                 | aaa     | am, pm                            |       |\n         * |                                 | aaaa    | a.m., p.m.                        | 1     |\n         * |                                 | aaaaa   | a, p                              |       |\n         * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |\n         * |                                 | bbb     | am, pm, noon, midnight            |       |\n         * |                                 | bbbb    | a.m., p.m., noon, midnight        | 1     |\n         * |                                 | bbbbb   | a, p, n, mi                       |       |\n         * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n         * |                                 | BBBB    | at night, in the morning, ...     | 1     |\n         * |                                 | BBBBB   | at night, in the morning, ...     |       |\n         * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n         * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 3     |\n         * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n         * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n         * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 3     |\n         * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n         * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n         * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 3     |\n         * |                                 | KK      | 01, 02, ..., 11, 00               |       |\n         * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n         * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 3     |\n         * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n         * | Minute                          | m       | 0, 1, ..., 59                     |       |\n         * |                                 | mo      | 0th, 1st, ..., 59th               | 3     |\n         * |                                 | mm      | 00, 01, ..., 59                   |       |\n         * | Second                          | s       | 0, 1, ..., 59                     |       |\n         * |                                 | so      | 0th, 1st, ..., 59th               | 3     |\n         * |                                 | ss      | 00, 01, ..., 59                   |       |\n         * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n         * |                                 | SS      | 00, 01, ..., 99                   |       |\n         * |                                 | SSS     | 000, 001, ..., 999                |       |\n         * |                                 | SSSS    | ...                               | 2     |\n         * | Long localized time             | p       | 12:00 AM                          | 3     |\n         * |                                 | pp      | 12:00:00 AM                       | 3     |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. Some patterns could be unlimited length (such as `yyyyyyyy`).\n         *    The output will be padded with zeros to match the length of the pattern.\n         *\n         *    `format(\"2017-11-06\", 'yyyyyyyy') //=> '00002017'`\n         *\n         * 3. These patterns are not in the Unicode Technical Standard #35:\n         *    - `o`: ordinal number modifier\n         *    - `p`: long localized time\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param time - the original date\n         * @param format - the string of tokens\n         * @returns the formatted date string\n         *\n         * @example\n         * ```js\n         * // Escape string by single quote characters:\n         * var result = format(\"15:00:00.000\", \"h 'o''clock'\")\n         * //=> \"3 o'clock\"\n         * ```\n         */\n        format(time: Iso.Time, format: string): string;\n        chain(time: Iso.Time): ITimeChain;\n    }\n    /**\n     * @internal\n     */\n    export interface ITimeChain extends ES.Chain<Iso.Time> {\n        getHour(): ES.Chain<number>;\n        getMinute(): ES.Chain<number>;\n        getSecond(): ES.Chain<number>;\n        getMillisecond(): ES.Chain<number>;\n        with(timeLike: {\n            hour?: number;\n            minute?: number;\n            second?: number;\n            millisecond?: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): ITimeChain;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): ITimeChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): ITimeChain;\n        until(other: Iso.Time, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(other: Iso.Time, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        round(options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): ITimeChain;\n        equals(other: Iso.Time): ES.Chain<boolean>;\n        toDateTime(date: Iso.Date): IDateTimeChain;\n        toZonedDateTime(item: {\n            date: Iso.Date;\n            timeZone: string;\n        }): IZonedDateTimeChain;\n        getFields(): ES.Chain<ES.TimeSlots>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/IYearMonthFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    import { IDateChain } from \"types/IDateFns\";\n    export interface IYearMonthFns {\n        fromNumbers(year: number, month: number): Iso.YearMonth;\n        isValid(yearMonth: unknown): yearMonth is Iso.YearMonth;\n        assertIsValid(yearMonth: unknown): asserts yearMonth is Iso.YearMonth;\n        getYear(yearMonth: Iso.YearMonth): number;\n        getMonth(yearMonth: Iso.YearMonth): number;\n        getDaysInMonth(yearMonth: Iso.YearMonth): number;\n        getDaysInYear(yearMonth: Iso.YearMonth): number;\n        inLeapYear(yearMonth: Iso.YearMonth): boolean;\n        with(yearMonth: Iso.YearMonth, yearMonthLike: {\n            year?: number;\n            month?: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.YearMonth;\n        add(yearMonth: Iso.YearMonth, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.YearMonth;\n        subtract(yearMonth: Iso.YearMonth, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.YearMonth;\n        until(yearMonth: Iso.YearMonth, other: Iso.YearMonth, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(yearMonth: Iso.YearMonth, other: Iso.YearMonth, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        equals(yearMonth: Iso.YearMonth, other: Iso.YearMonth): boolean;\n        isBefore(yearMonth: Iso.YearMonth, other: Iso.YearMonth): boolean;\n        isAfter(yearMonth: Iso.YearMonth, other: Iso.YearMonth): boolean;\n        toDate(yearMonth: Iso.YearMonth, day: number): Iso.Date;\n        getFields(yearMonth: Iso.YearMonth): ES.YearMonthSlots;\n        from(item: any, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.YearMonth;\n        compare(one: Iso.YearMonth, two: Iso.YearMonth): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | Era                             | G..GGG  | AD, BC                            |       |\n         * |                                 | GGGG    | Anno Domini, Before Christ        | 1     |\n         * |                                 | GGGGG   | A, B                              |       |\n         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 4     |\n         * |                                 | yo      | 44th, 1st, 0th, 17th              | 4,5   |\n         * |                                 | yy      | 44, 01, 00, 17                    | 4     |\n         * |                                 | yyy     | 044, 001, 1900, 2017              | 4     |\n         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 4     |\n         * |                                 | yyyyy   | ...                               | 2,4   |\n         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 4     |\n         * |                                 | uu      | -43, 01, 1900, 2017               | 4     |\n         * |                                 | uuu     | -043, 001, 1900, 2017             | 4     |\n         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 4     |\n         * |                                 | uuuuu   | ...                               | 2,4   |\n         * | Quarter                         | Q       | 1, 2, 3, 4                        |       |\n         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 5     |\n         * |                                 | QQ      | 01, 02, 03, 04                    |       |\n         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 1     |\n         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 3     |\n         * | Month                           | M       | 1, 2, ..., 12                     |       |\n         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 5     |\n         * |                                 | MM      | 01, 02, ..., 12                   |       |\n         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n         * |                                 | MMMM    | January, February, ..., December  | 1     |\n         * |                                 | MMMMM   | J, F, ..., D                      |       |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. Some patterns could be unlimited length (such as `yyyyyyyy`).\n         *    The output will be padded with zeros to match the length of the pattern.\n         *\n         *    `format(\"2017-11-06\", 'yyyyyyyy') //=> '00002017'`\n         *\n         * 3. `QQQQQ` could be not strictly numerical in some locales.\n         *    These tokens represent the shortest form of the quarter.\n         *\n         * 4. The main difference between `y` and `u` patterns are B.C. years:\n         *\n         *    | Year | `y` | `u` |\n         *    |------|-----|-----|\n         *    | AC 1 |   1 |   1 |\n         *    | BC 1 |   1 |   0 |\n         *    | BC 2 |   2 |  -1 |\n         *\n         *    Also `yy` always returns the last two digits of a year,\n         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n         *\n         *    | Year | `yy` | `uu` |\n         *    |------|------|------|\n         *    | 1    |   01 |   01 |\n         *    | 14   |   14 |   14 |\n         *    | 376  |   76 |  376 |\n         *    | 1453 |   53 | 1453 |\n         *\n         * 5. These patterns are not in the Unicode Technical Standard #35:\n         *    - `o`: ordinal number modifier\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param yearMonth - the original date\n         * @param format - the string of tokens\n         * @returns the formatted date string\n         *\n         * @example\n         * ```js\n         * // Represent 11 February 2014 in middle-endian format:\n         * var result = format(\"2014-02\", 'MM/yyyy')\n         * //=> '02/2014'\n         * ```\n         */\n        format(yearMonth: Iso.YearMonth, format: string): string;\n        chain(yearMonth: Iso.YearMonth): IYearMonthChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IYearMonthChain extends ES.Chain<Iso.YearMonth> {\n        getYear(): ES.Chain<number>;\n        getMonth(): ES.Chain<number>;\n        getDaysInMonth(): ES.Chain<number>;\n        getDaysInYear(): ES.Chain<number>;\n        inLeapYear(): ES.Chain<boolean>;\n        with(yearMonthLike: {\n            year?: number;\n            month?: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): IYearMonthChain;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IYearMonthChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IYearMonthChain;\n        until(other: Iso.YearMonth, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(other: Iso.YearMonth, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        equals(other: Iso.YearMonth): ES.Chain<boolean>;\n        isBefore(other: Iso.YearMonth): ES.Chain<boolean>;\n        isAfter(other: Iso.YearMonth): ES.Chain<boolean>;\n        toDate(day: number): IDateChain;\n        getFields(): ES.Chain<ES.YearMonthSlots>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/IMonthDayFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDateChain } from \"types/IDateFns\";\n    export interface IMonthDayFns {\n        fromNumbers(month: number, day: number): Iso.MonthDay;\n        isValid(monthDay: unknown): monthDay is Iso.MonthDay;\n        assertIsValid(monthDay: unknown): asserts monthDay is Iso.MonthDay;\n        getDay(monthDay: Iso.MonthDay): number;\n        getMonth(monthDay: Iso.MonthDay): number;\n        with(monthDay: Iso.MonthDay, monthDayLike: {\n            month: number;\n            day: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.MonthDay;\n        equals(monthDay: Iso.MonthDay, other: Iso.MonthDay): boolean;\n        toDate(monthDay: Iso.MonthDay, year: number): Iso.Date;\n        getFields(monthDay: Iso.MonthDay): {\n            month: number;\n            day: number;\n        };\n        from(item: any, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.MonthDay;\n        compare(one: Iso.MonthDay, two: Iso.MonthDay): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | Quarter                         | Q       | 1, 2, 3, 4                        |       |\n         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 3     |\n         * |                                 | QQ      | 01, 02, 03, 04                    |       |\n         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 1     |\n         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 2     |\n         * | Month                           | M       | 1, 2, ..., 12                     |       |\n         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 3     |\n         * |                                 | MM      | 01, 02, ..., 12                   |       |\n         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n         * |                                 | MMMM    | January, February, ..., December  | 1     |\n         * |                                 | MMMMM   | J, F, ..., D                      |       |\n         * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n         * |                                 | do      | 1st, 2nd, ..., 31st               | 3    |\n         * |                                 | dd      | 01, 02, ..., 31                   |       |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. `QQQQQ` could be not strictly numerical in some locales.\n         *    These tokens represent the shortest form of the quarter.\n         *\n         *\n         * 3. These patterns are not in the Unicode Technical Standard #35:\n         *    - `o`: ordinal number modifier\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param monthDay - the original date\n         * @param format - the string of tokens\n         * @returns the formatted date string\n         *\n         * @example\n         * ```js\n         * // Represent 11 February 2014 in middle-endian format:\n         * var result = format(\"--02-11\", 'MM/dd')\n         * //=> '02/11'\n         * ```\n         */\n        format(monthDay: Iso.MonthDay, format: string): string;\n        chain(monthDay: Iso.MonthDay): IMonthDayChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IMonthDayChain extends ES.Chain<Iso.MonthDay> {\n        getDay(): ES.Chain<number>;\n        getMonth(): ES.Chain<number>;\n        with(monthDayLike: {\n            month: number;\n            day: number;\n        }, options?: {\n            overflow: ES.TemporalOverflow;\n        }): IMonthDayChain;\n        equals(other: Iso.MonthDay): ES.Chain<boolean>;\n        toDate(year: number): IDateChain;\n        getFields(): ES.Chain<{\n            month: number;\n            day: number;\n        }>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/IZonedDateTimeFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IInstantChain } from \"types/IInstantFns\";\n    import { IDateChain } from \"types/IDateFns\";\n    import { ITimeChain } from \"types/ITimeFns\";\n    import { IYearMonthChain } from \"types/IYearMonthFns\";\n    import { IMonthDayChain } from \"types/IMonthDayFns\";\n    import { IDateTimeChain } from \"types/IDateTimeFns\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    export interface IZonedDateTimeFns {\n        /**\n         * This method gets the current date, time, time zone, and time zone offset according to the system settings. Optionally a time zone can be given in which the time is computed, instead of the current system time zone.\n         *\n         * @param timeZone The time zone to get the current date and time in as a string. If not given, the current system time zone will be used.\n         * @returns an `Iso.ZonedDateTime` string representing the current system date, time, time zone, and time zone offset.\n         */\n        now(timeZone?: string): Iso.ZonedDateTime;\n        /**\n         * This method gets the current system time zone. This will usually be a named [IANA time zone](https://www.iana.org/time-zones), as that is how most people configure their computers.\n         *\n         * @returns a string representing the time zone according to the current system settings.\n         */\n        currentTimeZone(): string;\n        fromEpochMilliseconds(epochMilliseconds: number, timeZone: string): Iso.ZonedDateTime;\n        isValid(zonedDateTime: unknown): zonedDateTime is Iso.ZonedDateTime;\n        assertIsValid(zonedDateTime: unknown): asserts zonedDateTime is Iso.ZonedDateTime;\n        getTimeZone(zonedDateTime: Iso.ZonedDateTime): string;\n        getYear(zonedDateTime: Iso.ZonedDateTime): number;\n        getMonth(zonedDateTime: Iso.ZonedDateTime): number;\n        getDay(zonedDateTime: Iso.ZonedDateTime): number;\n        getHour(zonedDateTime: Iso.ZonedDateTime): number;\n        getMinute(zonedDateTime: Iso.ZonedDateTime): number;\n        getSecond(zonedDateTime: Iso.ZonedDateTime): number;\n        getMillisecond(zonedDateTime: Iso.ZonedDateTime): number;\n        getEpochSeconds(zonedDateTime: Iso.ZonedDateTime): number;\n        getEpochMilliseconds(zonedDateTime: Iso.ZonedDateTime): number;\n        getDayOfWeek(zonedDateTime: Iso.ZonedDateTime): number;\n        getDayOfYear(zonedDateTime: Iso.ZonedDateTime): number;\n        getWeekOfYear(zonedDateTime: Iso.ZonedDateTime): number;\n        getHoursInDay(zonedDateTime: Iso.ZonedDateTime): number;\n        getDaysInMonth(zonedDateTime: Iso.ZonedDateTime): number;\n        getDaysInYear(zonedDateTime: Iso.ZonedDateTime): number;\n        inLeapYear(zonedDateTime: Iso.ZonedDateTime): boolean;\n        getOffset(zonedDateTime: Iso.ZonedDateTime): string;\n        getOffsetMilliseconds(zonedDateTime: Iso.ZonedDateTime): number;\n        with(zonedDateTime: Iso.ZonedDateTime, zonedDateTimeLike: {\n            day?: number;\n            hour?: number;\n            millisecond?: number;\n            minute?: number;\n            month?: number;\n            second?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n            disambiguation?: ES.TemporalDisambiguation;\n            offset?: ES.TemporalOffset;\n        }): Iso.ZonedDateTime;\n        withDate(zonedDateTime: Iso.ZonedDateTime, date: Iso.Date | ES.DateSlots): Iso.ZonedDateTime;\n        withTime(zonedDateTime: Iso.ZonedDateTime, time: Iso.Time | Partial<ES.TimeSlots>): Iso.ZonedDateTime;\n        withTimeZone(zonedDateTime: Iso.ZonedDateTime, timeZone: string): Iso.ZonedDateTime;\n        add(zonedDateTime: Iso.ZonedDateTime, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.ZonedDateTime;\n        subtract(zonedDateTime: Iso.ZonedDateTime, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.ZonedDateTime;\n        until(zonedDateTime: Iso.ZonedDateTime, other: Iso.ZonedDateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(zonedDateTime: Iso.ZonedDateTime, other: Iso.ZonedDateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        round(zonedDateTime: Iso.ZonedDateTime, options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.ZonedDateTime;\n        equals(zonedDateTime: Iso.ZonedDateTime, other: Iso.ZonedDateTime): boolean;\n        startOfDay(zonedDateTime: Iso.ZonedDateTime): Iso.ZonedDateTime;\n        toInstant(zonedDateTime: Iso.ZonedDateTime): Iso.Instant;\n        toDate(zonedDateTime: Iso.ZonedDateTime): Iso.Date;\n        toTime(zonedDateTime: Iso.ZonedDateTime): Iso.Time;\n        toDateTime(zonedDateTime: Iso.ZonedDateTime): Iso.DateTime;\n        toYearMonth(zonedDateTime: Iso.ZonedDateTime): Iso.YearMonth;\n        toMonthDay(zonedDateTime: Iso.ZonedDateTime): Iso.MonthDay;\n        getFields(zonedDateTime: Iso.ZonedDateTime): {\n            day: number;\n            hour: number;\n            millisecond: number;\n            minute: number;\n            month: number;\n            second: number;\n            year: number;\n            offset: string;\n            timeZone: string;\n        };\n        from(item: any, options?: {\n            overflow?: ES.TemporalOverflow;\n            disambiguation?: ES.TemporalDisambiguation;\n            offset?: ES.TemporalOffset;\n        }): Iso.ZonedDateTime;\n        compare(one: Iso.ZonedDateTime, two: Iso.ZonedDateTime): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | Era                             | G..GGG  | AD, BC                            |       |\n         * |                                 | GGGG    | Anno Domini, Before Christ        | 1     |\n         * |                                 | GGGGG   | A, B                              |       |\n         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 4     |\n         * |                                 | yo      | 44th, 1st, 0th, 17th              | 4,5   |\n         * |                                 | yy      | 44, 01, 00, 17                    | 4     |\n         * |                                 | yyy     | 044, 001, 1900, 2017              | 4     |\n         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 4     |\n         * |                                 | yyyyy   | ...                               | 2,4   |\n         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 4     |\n         * |                                 | uu      | -43, 01, 1900, 2017               | 4     |\n         * |                                 | uuu     | -043, 001, 1900, 2017             | 4     |\n         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 4     |\n         * |                                 | uuuuu   | ...                               | 2,4   |\n         * | Quarter                         | Q       | 1, 2, 3, 4                        |       |\n         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 5     |\n         * |                                 | QQ      | 01, 02, 03, 04                    |       |\n         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 1     |\n         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 3     |\n         * | Month                           | M       | 1, 2, ..., 12                     |       |\n         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 5     |\n         * |                                 | MM      | 01, 02, ..., 12                   |       |\n         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n         * |                                 | MMMM    | January, February, ..., December  | 1     |\n         * |                                 | MMMMM   | J, F, ..., D                      |       |\n         * | ISO week of year                | I       | 1, 2, ..., 53                     | 5     |\n         * |                                 | Io      | 1st, 2nd, ..., 53th               | 5     |\n         * |                                 | II      | 01, 02, ..., 53                   | 5     |\n         * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n         * |                                 | do      | 1st, 2nd, ..., 31st               | 5     |\n         * |                                 | dd      | 01, 02, ..., 31                   |       |\n         * | ISO day of week                 | i       | 1, 2, 3, ..., 7                   | 5     |\n         * |                                 | io      | 1st, 2nd, ..., 7th                | 5     |\n         * |                                 | ii      | 01, 02, ..., 07                   | 5     |\n         * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 5     |\n         * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 1,5   |\n         * |                                 | iiiii   | M, T, W, T, F, S, S               | 5     |\n         * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |\n         * | AM, PM                          | a..aa   | AM, PM                            |       |\n         * |                                 | aaa     | am, pm                            |       |\n         * |                                 | aaaa    | a.m., p.m.                        | 1     |\n         * |                                 | aaaaa   | a, p                              |       |\n         * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |\n         * |                                 | bbb     | am, pm, noon, midnight            |       |\n         * |                                 | bbbb    | a.m., p.m., noon, midnight        | 1     |\n         * |                                 | bbbbb   | a, p, n, mi                       |       |\n         * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n         * |                                 | BBBB    | at night, in the morning, ...     | 1     |\n         * |                                 | BBBBB   | at night, in the morning, ...     |       |\n         * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n         * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |\n         * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n         * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n         * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |\n         * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n         * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n         * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |\n         * |                                 | KK      | 01, 02, ..., 11, 00               |       |\n         * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n         * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |\n         * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n         * | Minute                          | m       | 0, 1, ..., 59                     |       |\n         * |                                 | mo      | 0th, 1st, ..., 59th               | 5     |\n         * |                                 | mm      | 00, 01, ..., 59                   |       |\n         * | Second                          | s       | 0, 1, ..., 59                     |       |\n         * |                                 | so      | 0th, 1st, ..., 59th               | 5     |\n         * |                                 | ss      | 00, 01, ..., 59                   |       |\n         * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n         * |                                 | SS      | 00, 01, ..., 99                   |       |\n         * |                                 | SSS     | 000, 001, ..., 999                |       |\n         * |                                 | SSSS    | ...                               | 2     |\n         * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |\n         * |                                 | XX      | -0800, +0530, Z                   |       |\n         * |                                 | XXX     | -08:00, +05:30, Z                 |       |\n         * |                                 | XXXX    | -0800, +0530, Z, +123456          | 1     |\n         * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |\n         * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |\n         * |                                 | xx      | -0800, +0530, +0000               |       |\n         * |                                 | xxx     | -08:00, +05:30, +00:00            | 1     |\n         * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |\n         * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |\n         * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |\n         * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 1     |\n         * | Timezone (specific non-locat.)  | z...zzz | CST, CST, CST                     |       |\n         * |                                 | zzzz    | Central Standard Time             | 1     |\n         * | Long localized date             | P       | 04/29/1453                        | 5     |\n         * |                                 | PP      | Apr 29, 1453                      | 5     |\n         * |                                 | PPP     | April 29th, 1453                  | 5     |\n         * |                                 | PPPP    | Friday, April 29th, 1453          | 1,5   |\n         * | Long localized time             | p       | 12:00 AM                          | 5     |\n         * |                                 | pp      | 12:00:00 AM                       | 5     |\n         * |                                 | ppp     | 12:00:00 AM CDT                   | 5     |\n         * |                                 | pppp    | 12:00:00 AM Central Daylight Time | 1,5   |\n         * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 5     |\n         * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 5     |\n         * |                                 | PPPppp  | April 29th, 1453 at ...           | 5     |\n         * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 1,5   |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. Some patterns could be unlimited length (such as `yyyyyyyy`).\n         *    The output will be padded with zeros to match the length of the pattern.\n         *\n         *    `format(\"2017-11-06\", 'yyyyyyyy') //=> '00002017'`\n         *\n         * 3. `QQQQQ` could be not strictly numerical in some locales.\n         *    These tokens represent the shortest form of the quarter.\n         *\n         * 4. The main difference between `y` and `u` patterns are B.C. years:\n         *\n         *    | Year | `y` | `u` |\n         *    |------|-----|-----|\n         *    | AC 1 |   1 |   1 |\n         *    | BC 1 |   1 |   0 |\n         *    | BC 2 |   2 |  -1 |\n         *\n         *    Also `yy` always returns the last two digits of a year,\n         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n         *\n         *    | Year | `yy` | `uu` |\n         *    |------|------|------|\n         *    | 1    |   01 |   01 |\n         *    | 14   |   14 |   14 |\n         *    | 376  |   76 |  376 |\n         *    | 1453 |   53 | 1453 |\n         *\n         * 5. These patterns are not in the Unicode Technical Standard #35:\n         *    - `i`: ISO day of week\n         *    - `I`: ISO week of year\n         *    - `o`: ordinal number modifier\n         *    - `P`: long localized date\n         *    - `p`: long localized time\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param {Iso.ZonedDateTime} zonedDateTime - the original date\n         * @param {String} format - the string of tokens\n         * @returns {string} the formatted date string\n         *\n         * @example\n         * ```js\n         * // Represent 11 February 2014 in middle-endian format:\n         * var result = format(\"2014-02-11T00:00:00+00:00[UTC]\", 'MM/dd/yyyy')\n         * //=> '02/11/2014'\n         * ```\n         */\n        format(zonedDateTime: Iso.ZonedDateTime, format: string): string;\n        chain(zonedDateTime: Iso.ZonedDateTime): IZonedDateTimeChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IZonedDateTimeChain extends ES.Chain<Iso.ZonedDateTime> {\n        getTimeZone(): ES.Chain<string>;\n        getYear(): ES.Chain<number>;\n        getMonth(): ES.Chain<number>;\n        getDay(): ES.Chain<number>;\n        getHour(): ES.Chain<number>;\n        getMinute(): ES.Chain<number>;\n        getSecond(): ES.Chain<number>;\n        getMillisecond(): ES.Chain<number>;\n        getEpochSeconds(): ES.Chain<number>;\n        getEpochMilliseconds(): ES.Chain<number>;\n        getDayOfWeek(): ES.Chain<number>;\n        getDayOfYear(): ES.Chain<number>;\n        getWeekOfYear(): ES.Chain<number>;\n        getHoursInDay(): ES.Chain<number>;\n        getDaysInMonth(): ES.Chain<number>;\n        getDaysInYear(): ES.Chain<number>;\n        inLeapYear(): ES.Chain<boolean>;\n        getOffset(): ES.Chain<string>;\n        getOffsetMilliseconds(): ES.Chain<number>;\n        with(zonedDateTimeLike: {\n            day?: number;\n            hour?: number;\n            millisecond?: number;\n            minute?: number;\n            month?: number;\n            monthCode?: number;\n            second?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n            disambiguation?: ES.TemporalDisambiguation;\n            offset?: ES.TemporalOffset;\n        }): IZonedDateTimeChain;\n        withDate(date: Iso.Date | ES.DateSlots): IZonedDateTimeChain;\n        withTime(time: Iso.Time | Partial<ES.TimeSlots>): IZonedDateTimeChain;\n        withTimeZone(timeZone: string): IZonedDateTimeChain;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IZonedDateTimeChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IZonedDateTimeChain;\n        until(other: Iso.ZonedDateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(other: Iso.ZonedDateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        round(options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IZonedDateTimeChain;\n        equals(other: Iso.ZonedDateTime): ES.Chain<boolean>;\n        startOfDay(): IZonedDateTimeChain;\n        toInstant(): IInstantChain;\n        toDate(): IDateChain;\n        toTime(): ITimeChain;\n        toDateTime(): IDateTimeChain;\n        toYearMonth(): IYearMonthChain;\n        toMonthDay(): IMonthDayChain;\n        getFields(): ES.Chain<{\n            day: number;\n            hour: number;\n            millisecond: number;\n            minute: number;\n            month: number;\n            second: number;\n            year: number;\n            offset: string;\n            timeZone: string;\n        }>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/IDateTimeFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    import { IZonedDateTimeChain } from \"types/IZonedDateTimeFns\";\n    import { IDateChain } from \"types/IDateFns\";\n    import { IYearMonthChain } from \"types/IYearMonthFns\";\n    import { IMonthDayChain } from \"types/IMonthDayFns\";\n    import { ITimeChain } from \"types/ITimeFns\";\n    export interface IDateTimeFns {\n        /**\n         * This method gets the current calendar date and wall-clock time according to the system settings. Optionally a time zone can be given in which the time is computed, instead of the current system time zone.\n         *\n         * @param timeZone The time zone to get the current date and time in, as a string. If not given, the current system time zone will be used.\n         * @returns an `Iso.DateTime` string representing the date and time.\n         */\n        now(timeZone?: string): Iso.DateTime;\n        fromNumbers(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number): Iso.DateTime;\n        isValid(dateTime: unknown): dateTime is Iso.DateTime;\n        assertIsValid(dateTime: unknown): asserts dateTime is Iso.DateTime;\n        getYear(dateTime: Iso.DateTime): number;\n        getMonth(dateTime: Iso.DateTime): number;\n        getDay(dateTime: Iso.DateTime): number;\n        getHour(dateTime: Iso.DateTime): number;\n        getMinute(dateTime: Iso.DateTime): number;\n        getSecond(dateTime: Iso.DateTime): number;\n        getMillisecond(dateTime: Iso.DateTime): number;\n        getDayOfWeek(dateTime: Iso.DateTime): number;\n        getDayOfYear(dateTime: Iso.DateTime): number;\n        getWeekOfYear(dateTime: Iso.DateTime): number;\n        getDaysInYear(dateTime: Iso.DateTime): number;\n        getDaysInMonth(dateTime: Iso.DateTime): number;\n        getInLeapYear(dateTime: Iso.DateTime): boolean;\n        with(dateTime: Iso.DateTime, temporalDateTimeLike: {\n            day?: number;\n            hour?: number;\n            millisecond?: number;\n            minute?: number;\n            month?: number;\n            second?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.DateTime;\n        withTime(dateTime: Iso.DateTime, time?: Iso.Time | undefined): Iso.DateTime;\n        withDate(dateTime: Iso.DateTime, temporalDate: Iso.Date): Iso.DateTime;\n        add(dateTime: Iso.DateTime, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.DateTime;\n        subtract(dateTime: Iso.DateTime, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.DateTime;\n        until(from: Iso.DateTime, until: Iso.DateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(dateTime: Iso.DateTime, other: Iso.DateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        round(dateTime: Iso.DateTime, options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.DateTime;\n        equals(dateTime: Iso.DateTime, other: Iso.DateTime): boolean;\n        isBefore(dateTime: Iso.DateTime, other: Iso.DateTime): boolean;\n        isAfter(dateTime: Iso.DateTime, other: Iso.DateTime): boolean;\n        toZonedDateTime(dateTime: Iso.DateTime, timeZone: string, options?: {\n            disambiguation: ES.TemporalDisambiguation;\n        }): Iso.ZonedDateTime;\n        toDate(dateTime: Iso.DateTime): Iso.Date;\n        toYearMonth(dateTime: Iso.DateTime): Iso.YearMonth;\n        toMonthDay(dateTime: Iso.DateTime): Iso.MonthDay;\n        toTime(dateTime: Iso.DateTime): Iso.Time;\n        getFields(dateTime: Iso.DateTime): ES.DateTimeSlots;\n        from(item: any, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.DateTime;\n        compare(one: Iso.DateTime, two: Iso.DateTime): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | Era                             | G..GGG  | AD, BC                            |       |\n         * |                                 | GGGG    | Anno Domini, Before Christ        | 1     |\n         * |                                 | GGGGG   | A, B                              |       |\n         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 4     |\n         * |                                 | yo      | 44th, 1st, 0th, 17th              | 4,5   |\n         * |                                 | yy      | 44, 01, 00, 17                    | 4     |\n         * |                                 | yyy     | 044, 001, 1900, 2017              | 4     |\n         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 4     |\n         * |                                 | yyyyy   | ...                               | 2,4   |\n         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 4     |\n         * |                                 | uu      | -43, 01, 1900, 2017               | 4     |\n         * |                                 | uuu     | -043, 001, 1900, 2017             | 4     |\n         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 4     |\n         * |                                 | uuuuu   | ...                               | 2,4   |\n         * | Quarter                         | Q       | 1, 2, 3, 4                        |       |\n         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 5     |\n         * |                                 | QQ      | 01, 02, 03, 04                    |       |\n         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 1     |\n         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 3     |\n         * | Month                           | M       | 1, 2, ..., 12                     |       |\n         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 5     |\n         * |                                 | MM      | 01, 02, ..., 12                   |       |\n         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n         * |                                 | MMMM    | January, February, ..., December  | 1     |\n         * |                                 | MMMMM   | J, F, ..., D                      |       |\n         * | ISO week of year                | I       | 1, 2, ..., 53                     | 5     |\n         * |                                 | Io      | 1st, 2nd, ..., 53th               | 5     |\n         * |                                 | II      | 01, 02, ..., 53                   | 5     |\n         * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n         * |                                 | do      | 1st, 2nd, ..., 31st               | 5     |\n         * |                                 | dd      | 01, 02, ..., 31                   |       |\n         * | ISO day of week                 | i       | 1, 2, 3, ..., 7                   | 5     |\n         * |                                 | io      | 1st, 2nd, ..., 7th                | 5     |\n         * |                                 | ii      | 01, 02, ..., 07                   | 5     |\n         * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 5     |\n         * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 1,5   |\n         * |                                 | iiiii   | M, T, W, T, F, S, S               | 5     |\n         * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |\n         * | AM, PM                          | a..aa   | AM, PM                            |       |\n         * |                                 | aaa     | am, pm                            |       |\n         * |                                 | aaaa    | a.m., p.m.                        | 1     |\n         * |                                 | aaaaa   | a, p                              |       |\n         * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |\n         * |                                 | bbb     | am, pm, noon, midnight            |       |\n         * |                                 | bbbb    | a.m., p.m., noon, midnight        | 1     |\n         * |                                 | bbbbb   | a, p, n, mi                       |       |\n         * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |\n         * |                                 | BBBB    | at night, in the morning, ...     | 1     |\n         * |                                 | BBBBB   | at night, in the morning, ...     |       |\n         * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |\n         * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |\n         * |                                 | hh      | 01, 02, ..., 11, 12               |       |\n         * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |\n         * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |\n         * |                                 | HH      | 00, 01, 02, ..., 23               |       |\n         * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |\n         * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |\n         * |                                 | KK      | 01, 02, ..., 11, 00               |       |\n         * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |\n         * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |\n         * |                                 | kk      | 24, 01, 02, ..., 23               |       |\n         * | Minute                          | m       | 0, 1, ..., 59                     |       |\n         * |                                 | mo      | 0th, 1st, ..., 59th               | 5     |\n         * |                                 | mm      | 00, 01, ..., 59                   |       |\n         * | Second                          | s       | 0, 1, ..., 59                     |       |\n         * |                                 | so      | 0th, 1st, ..., 59th               | 5     |\n         * |                                 | ss      | 00, 01, ..., 59                   |       |\n         * | Fraction of second              | S       | 0, 1, ..., 9                      |       |\n         * |                                 | SS      | 00, 01, ..., 99                   |       |\n         * |                                 | SSS     | 000, 001, ..., 999                |       |\n         * |                                 | SSSS    | ...                               | 2     |\n         * | Long localized date             | P       | 04/29/1453                        | 5     |\n         * |                                 | PP      | Apr 29, 1453                      | 5     |\n         * |                                 | PPP     | April 29th, 1453                  | 5     |\n         * |                                 | PPPP    | Friday, April 29th, 1453          | 1,5   |\n         * | Long localized time             | p       | 12:00 AM                          | 5     |\n         * |                                 | pp      | 12:00:00 AM                       | 5     |\n         * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 5     |\n         * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 5     |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. Some patterns could be unlimited length (such as `yyyyyyyy`).\n         *    The output will be padded with zeros to match the length of the pattern.\n         *\n         *    `format(\"2017-11-06\", 'yyyyyyyy') //=> '00002017'`\n         *\n         * 3. `QQQQQ` could be not strictly numerical in some locales.\n         *    These tokens represent the shortest form of the quarter.\n         *\n         * 4. The main difference between `y` and `u` patterns are B.C. years:\n         *\n         *    | Year | `y` | `u` |\n         *    |------|-----|-----|\n         *    | AC 1 |   1 |   1 |\n         *    | BC 1 |   1 |   0 |\n         *    | BC 2 |   2 |  -1 |\n         *\n         *    Also `yy` always returns the last two digits of a year,\n         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n         *\n         *    | Year | `yy` | `uu` |\n         *    |------|------|------|\n         *    | 1    |   01 |   01 |\n         *    | 14   |   14 |   14 |\n         *    | 376  |   76 |  376 |\n         *    | 1453 |   53 | 1453 |\n         *\n         * 5. These patterns are not in the Unicode Technical Standard #35:\n         *    - `i`: ISO day of week\n         *    - `I`: ISO week of year\n         *    - `o`: ordinal number modifier\n         *    - `P`: long localized date\n         *    - `p`: long localized time\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param dateTime - the original date\n         * @param format - the string of tokens\n         * @returns the formatted date string\n         *\n         * @example\n         * ```js\n         * // Represent 11 February 2014 in middle-endian format:\n         * var result = format(\"2014-02-11T00:00:00.000\", 'MM/dd/yyyy')\n         * //=> '02/11/2014'\n         * ```\n         *\n         * @example\n         * ```js\n         * // Escape string by single quote characters:\n         * var result = format(\"2014-02-11T15:00:00.000\", \"h 'o''clock'\")\n         * //=> \"3 o'clock\"\n         * ```\n         */\n        format(dateTime: Iso.DateTime, formatString: string): string;\n        chain(dateTime: Iso.DateTime): IDateTimeChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IDateTimeChain extends ES.Chain<Iso.DateTime> {\n        getYear(): ES.Chain<number>;\n        getMonth(): ES.Chain<number>;\n        getDay(): ES.Chain<number>;\n        getHour(): ES.Chain<number>;\n        getMinute(): ES.Chain<number>;\n        getSecond(): ES.Chain<number>;\n        getMillisecond(): ES.Chain<number>;\n        getDayOfWeek(): ES.Chain<number>;\n        getDayOfYear(): ES.Chain<number>;\n        getWeekOfYear(): ES.Chain<number>;\n        getDaysInYear(): ES.Chain<number>;\n        getDaysInMonth(): ES.Chain<number>;\n        getInLeapYear(): ES.Chain<boolean>;\n        with(temporalDateTimeLike: {\n            day?: number;\n            hour?: number;\n            millisecond?: number;\n            minute?: number;\n            month?: number;\n            second?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateTimeChain;\n        withTime(time?: Iso.Time | undefined): IDateTimeChain;\n        withDate(temporalDate: Iso.Date): IDateTimeChain;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateTimeChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateTimeChain;\n        until(until: Iso.DateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(other: Iso.DateTime, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        round(options: {\n            smallestUnit: Exclude<ES.TemporalSingularUnit, 'year' | 'month' | 'week'>;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDateTimeChain;\n        equals(other: Iso.DateTime): ES.Chain<boolean>;\n        isBefore(other: Iso.DateTime): ES.Chain<boolean>;\n        isAfter(other: Iso.DateTime): ES.Chain<boolean>;\n        toZonedDateTime(timeZone: string, options?: {\n            disambiguation: ES.TemporalDisambiguation;\n        }): IZonedDateTimeChain;\n        toDate(): IDateChain;\n        toYearMonth(): IYearMonthChain;\n        toMonthDay(): IMonthDayChain;\n        toTime(): ITimeChain;\n        getFields(): ES.Chain<ES.DateTimeSlots>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/IDateFns\" {\n    import { Iso } from \"iso-types\";\n    import * as ES from \"ecmascript\";\n    import { IDurationChain } from \"types/IDurationFns\";\n    import { IDateTimeChain } from \"types/IDateTimeFns\";\n    import { IZonedDateTimeChain } from \"types/IZonedDateTimeFns\";\n    import { IYearMonthChain } from \"types/IYearMonthFns\";\n    import { IMonthDayChain } from \"types/IMonthDayFns\";\n    export interface IDateFns {\n        /**\n         * This method gets the current calendar date according to the system settings. Optionally a time zone can be given in which the time is computed, instead of the current system time zone.\n         *\n         * @param timeZone The time zone to get the current date and time in, as a string. If not given, the current system time zone will be used.\n         * @returns an `Iso.Date` string representing the date.\n         */\n        now(timeZone?: string): Iso.Date;\n        fromNumbers(year: number, month: number, day: number): Iso.Date;\n        isValid(date: unknown): date is Iso.Date;\n        assertIsValid(date: unknown): asserts date is Iso.Date;\n        getYear(date: Iso.Date): number;\n        getMonth(date: Iso.Date): number;\n        getDay(date: Iso.Date): number;\n        getDayOfWeek(date: Iso.Date): number;\n        getDayOfYear(date: Iso.Date): number;\n        getWeekOfYear(date: Iso.Date): number;\n        getDaysInMonth(date: Iso.Date): number;\n        getDaysInYear(date: Iso.Date): number;\n        inLeapYear(date: Iso.Date): boolean;\n        with(dateTime: Iso.Date, temporalDateLike: {\n            day?: number;\n            month?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.Date;\n        add(date: Iso.Date, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.Date;\n        subtract(date: Iso.Date, temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): Iso.Date;\n        until(date: Iso.Date, other: Iso.Date, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        since(date: Iso.Date, other: Iso.Date, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): Iso.Duration;\n        equals(date: Iso.Date, other: Iso.Date): boolean;\n        isBefore(date: Iso.Date, other: Iso.Date): boolean;\n        isAfter(date: Iso.Date, other: Iso.Date): boolean;\n        toDateTime(date: Iso.Date, time?: Iso.Time): Iso.DateTime;\n        toZonedDateTime(date: Iso.Date, item: {\n            timeZone: string;\n            time?: Iso.Time;\n        } | string): Iso.ZonedDateTime;\n        toYearMonth(date: Iso.Date): Iso.YearMonth;\n        toMonthDay(date: Iso.Date): Iso.MonthDay;\n        getFields(date: Iso.Date): ES.DateSlots;\n        from(item: any, options?: {\n            overflow: ES.TemporalOverflow;\n        }): Iso.Date;\n        compare(one: Iso.Date, two: Iso.Date): number;\n        /**\n         * @summary Format the ZonedDateTime.\n         *\n         * @description\n         * Return the formatted ZonedDateTime string in the given format.\n         *\n         * The characters wrapped between two single quotes characters (') are escaped.\n         * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.\n         * (see the last example)\n         *\n         * Format of the string is based on Unicode Technical Standard #35:\n         * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n         * with a few additions (see note 7 below the table).\n         *\n         * Accepted patterns:\n         *\n         * | Unit                            | Pattern | Result examples                   | Notes |\n         * |:------------------------------  |:------  |:--------------------------------  |:----  |\n         * | Era                             | G..GGG  | AD, BC                            |       |\n         * |                                 | GGGG    | Anno Domini, Before Christ        | 1     |\n         * |                                 | GGGGG   | A, B                              |       |\n         * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 4     |\n         * |                                 | yo      | 44th, 1st, 0th, 17th              | 4,5   |\n         * |                                 | yy      | 44, 01, 00, 17                    | 4     |\n         * |                                 | yyy     | 044, 001, 1900, 2017              | 4     |\n         * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 4     |\n         * |                                 | yyyyy   | ...                               | 2,4   |\n         * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 4     |\n         * |                                 | uu      | -43, 01, 1900, 2017               | 4     |\n         * |                                 | uuu     | -043, 001, 1900, 2017             | 4     |\n         * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 4     |\n         * |                                 | uuuuu   | ...                               | 2,4   |\n         * | Quarter                         | Q       | 1, 2, 3, 4                        |       |\n         * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 5     |\n         * |                                 | QQ      | 01, 02, 03, 04                    |       |\n         * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |\n         * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 1     |\n         * |                                 | QQQQQ   | 1, 2, 3, 4                        | 3     |\n         * | Month                           | M       | 1, 2, ..., 12                     |       |\n         * |                                 | Mo      | 1st, 2nd, ..., 12th               | 5     |\n         * |                                 | MM      | 01, 02, ..., 12                   |       |\n         * |                                 | MMM     | Jan, Feb, ..., Dec                |       |\n         * |                                 | MMMM    | January, February, ..., December  | 1     |\n         * |                                 | MMMMM   | J, F, ..., D                      |       |\n         * | ISO week of year                | I       | 1, 2, ..., 53                     | 5     |\n         * |                                 | Io      | 1st, 2nd, ..., 53th               | 5     |\n         * |                                 | II      | 01, 02, ..., 53                   | 5     |\n         * | Day of month                    | d       | 1, 2, ..., 31                     |       |\n         * |                                 | do      | 1st, 2nd, ..., 31st               | 5     |\n         * |                                 | dd      | 01, 02, ..., 31                   |       |\n         * | ISO day of week                 | i       | 1, 2, 3, ..., 7                   | 5     |\n         * |                                 | io      | 1st, 2nd, ..., 7th                | 5     |\n         * |                                 | ii      | 01, 02, ..., 07                   | 5     |\n         * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 5     |\n         * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 1,5   |\n         * |                                 | iiiii   | M, T, W, T, F, S, S               | 5     |\n         * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |\n         * | Long localized date             | P       | 04/29/1453                        | 5     |\n         * |                                 | PP      | Apr 29, 1453                      | 5     |\n         * |                                 | PPP     | April 29th, 1453                  | 5     |\n         * |                                 | PPPP    | Friday, April 29th, 1453          | 1,5   |\n         * Notes:\n         * 1. Any sequence of the identical letters is a pattern, unless it is escaped by\n         *    the single quote characters (see below).\n         *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)\n         *    the output will be the same as default pattern for this unit, usually\n         *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units\n         *    are marked with \"2\" in the last column of the table.\n         *\n         *    `format(\"2017-11-06\", 'MMM') //=> 'Nov'`\n         *\n         *    `format(\"2017-11-06\", 'MMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMM') //=> 'N'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMM') //=> 'November'`\n         *\n         *    `format(\"2017-11-06\", 'MMMMMMM') //=> 'November'`\n         *\n         * 2. Some patterns could be unlimited length (such as `yyyyyyyy`).\n         *    The output will be padded with zeros to match the length of the pattern.\n         *\n         *    `format(\"2017-11-06\", 'yyyyyyyy') //=> '00002017'`\n         *\n         * 3. `QQQQQ` could be not strictly numerical in some locales.\n         *    These tokens represent the shortest form of the quarter.\n         *\n         * 4. The main difference between `y` and `u` patterns are B.C. years:\n         *\n         *    | Year | `y` | `u` |\n         *    |------|-----|-----|\n         *    | AC 1 |   1 |   1 |\n         *    | BC 1 |   1 |   0 |\n         *    | BC 2 |   2 |  -1 |\n         *\n         *    Also `yy` always returns the last two digits of a year,\n         *    while `uu` pads single digit years to 2 characters and returns other years unchanged:\n         *\n         *    | Year | `yy` | `uu` |\n         *    |------|------|------|\n         *    | 1    |   01 |   01 |\n         *    | 14   |   14 |   14 |\n         *    | 376  |   76 |  376 |\n         *    | 1453 |   53 | 1453 |\n         *\n         * 5. These patterns are not in the Unicode Technical Standard #35:\n         *    - `i`: ISO day of week\n         *    - `I`: ISO week of year\n         *    - `o`: ordinal number modifier\n         *    - `P`: long localized date\n         *    - `p`: long localized time\n         *\n         * - Characters are escaped using single quote symbols (`'`).\n         *\n         * @param date - the original date\n         * @param format - the string of tokens\n         * @returns the formatted date string\n         *\n         * @example\n         * ```js\n         * // Represent 11 February 2014 in middle-endian format:\n         * var result = format(\"2014-02-11\", 'MM/dd/yyyy')\n         * //=> '02/11/2014'\n         * ```\n         *\n         */\n        format(date: Iso.Date, format: string): string;\n        chain(date: Iso.Date): IDateChain;\n    }\n    /**\n     * @internal\n     */\n    export interface IDateChain extends ES.Chain<Iso.Date> {\n        getYear(): ES.Chain<number>;\n        getMonth(): ES.Chain<number>;\n        getDay(): ES.Chain<number>;\n        getDayOfWeek(): ES.Chain<number>;\n        getDayOfYear(): ES.Chain<number>;\n        getWeekOfYear(): ES.Chain<number>;\n        getDaysInMonth(): ES.Chain<number>;\n        getDaysInYear(): ES.Chain<number>;\n        inLeapYear(): ES.Chain<boolean>;\n        with(temporalDateLike: {\n            day?: number;\n            month?: number;\n            year?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateChain;\n        add(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateChain;\n        subtract(temporalDurationLike: Iso.Duration | {\n            years?: number;\n            months?: number;\n            weeks?: number;\n            days?: number;\n            hours?: number;\n            minutes?: number;\n            seconds?: number;\n            milliseconds?: number;\n        }, options?: {\n            overflow?: ES.TemporalOverflow;\n        }): IDateChain;\n        until(other: Iso.Date, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        since(other: Iso.Date, options?: {\n            largestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit | 'auto';\n            smallestUnit?: ES.TemporalSingularUnit | ES.TemporalPluralUnit;\n            roundingIncrement?: number;\n            roundingMode?: ES.TemporalRoundingMode;\n        }): IDurationChain;\n        equals(other: Iso.Date): ES.Chain<boolean>;\n        isBefore(other: Iso.Date): ES.Chain<boolean>;\n        isAfter(other: Iso.Date): ES.Chain<boolean>;\n        toDateTime(time?: Iso.Time): IDateTimeChain;\n        toZonedDateTime(item: {\n            timeZone: string;\n            time?: Iso.Time;\n        }): IZonedDateTimeChain;\n        toYearMonth(): IYearMonthChain;\n        toMonthDay(): IMonthDayChain;\n        getFields(): ES.Chain<ES.DateSlots>;\n        format(formatString: string): ES.Chain<string>;\n    }\n}\ndeclare module \"types/index\" {\n    export * from \"types/IDateFns\";\n    export * from \"types/IDateTimeFns\";\n    export * from \"types/IDurationFns\";\n    export * from \"types/IInstantFns\";\n    export * from \"types/IMonthDayFns\";\n    export * from \"types/ITimeFns\";\n    export * from \"types/IYearMonthFns\";\n    export * from \"types/IZonedDateTimeFns\";\n}\n\n    ",path:"file:///node_modules/iso-fns/index.d.ts"}],s=t(6582);function m(){var n=o.useState(!1),e=n[0],t=n[1];return o.useEffect((function(){if(document){var n=document.createElement("script");return n.src="https://unpkg.com/typescript@latest/lib/typescriptServices.js",n.type="text/javascript",n.addEventListener("load",(function(){return t(!0)})),document.body.appendChild(n),function(){document.body.removeChild(n),t(!1)}}}),[t]),e?o.createElement(l,null):null}var u="import { dateFns, timeFns, zonedDateTimeFns, dateTimeFns, instantFns, yearMonthFns, monthDayFns, durationFns, Iso } from 'https://cdn.skypack.dev/iso-fns@alpha'\n\nconst result = dateFns.add(\"2000-01-01\", {days:1})\nconsole.log(result)";function l(){var n=(0,r.Ik)(),e=(0,a.Z)().isDarkTheme;(0,o.useEffect)((function(){n&&(n.languages.typescript.typescriptDefaults.setCompilerOptions({target:n.languages.typescript.ScriptTarget.ES2016,allowNonTsExtensions:!0,moduleResolution:n.languages.typescript.ModuleResolutionKind.NodeJs,module:n.languages.typescript.ModuleKind.ES2016,noEmit:!0,lib:["dom"],typeRoots:["node_modules/@types"]}),n.languages.typescript.typescriptDefaults.pre,i.forEach((function(e){return n.languages.typescript.typescriptDefaults.addExtraLib(e.source,e.path)})))}),[n]);var t=o.useState(window.ts.transpile(u,{module:"ES6"})),s=t[0],m=t[1],l=o.useCallback((function(n){var e=window.ts.transpile(n,{module:"ES6"});m(e)}));return o.createElement(o.Fragment,null,o.createElement("div",null,o.createElement(r.ZP,{theme:e?"vs-dark":"vs-light",height:"300px",defaultValue:u,defaultLanguage:"typescript",options:{minimap:{enabled:!1},scrollbar:{vertical:"hidden"},overviewRulerBorder:!1,hideCursorInOverviewRuler:!0},onChange:l})),o.createElement("div",{style:{backgroundColor:e?"#242424":"#F8F8F8",minHeight:100}},o.createElement(d,{jsCode:s,variant:e?"dark":"light"})))}var d=function(n){var e=n.jsCode,t=n.variant,r=o.useState([]),a=r[0],i=r[1];return(0,o.useEffect)((function(){(0,s.Hook)(window.console,(function(n){i((function(e){return[].concat(e,[n])}))}),!1);var n=function(n){return n.error&&console.error(n.error.message),!0};return window.addEventListener("error",n),function(){(0,s.Unhook)(window.console),window.removeEventListener("error",n)}}),[]),o.useEffect((function(){if(i([]),document){var n=document.createElement("script"),t=function(n){var e=n.split("\n"),t=e.filter((function(n){return n.includes("import ")})).join("\n"),o=e.filter((function(n){return!n.includes("import ")})).join("\n");return{imports:t,rest:o}}(e),o=t.imports,r=t.rest;return n.innerText=o+"\n  try {\n  "+r+"\n  } catch (e) {\n    throw e\n  }",n.type="module",document.body.appendChild(n),function(){document.body.removeChild(n)}}}),[e,i]),"dark"===t?o.createElement(s.Console,{key:"dark-console",logs:a}):o.createElement(s.Console,{key:"light-console",logs:a,styles:{LOG_COLOR:"rgba(0,0,0,0.9)",LOG_BORDER:"rgb(240, 240, 240)",LOG_WARN_BACKGROUND:"hsl(50deg 100% 95%)",LOG_WARN_BORDER:"hsl(50deg 100% 88%)",LOG_WARN_COLOR:"hsl(39deg 100% 18%)",LOG_ERROR_BACKGROUND:"hsl(0deg 100% 97%)",LOG_ERROR_BORDER:"rgb(0deg 100% 92%)",LOG_ERROR_COLOR:"#f00",LOG_AMOUNT_COLOR:"#fff"}})}},8332:function(n,e,t){t.r(e),t.d(e,{default:function(){return s}});var o=t(2262),r=t(1262),a=t(7294),i=t(2263);function s(){var n=(0,i.Z)().siteConfig;return a.createElement(o.Z,{title:n.title+" Playground",description:"Use this playground to start experimenting with iso-fns"},a.createElement("main",null,a.createElement("div",{className:"container"},a.createElement("h1",null,"Playground"),a.createElement("h5",null,"Welcome! This integrated typescript editor is for you! Please play around with it all you like. You can check function results and any error messages in the console below. Have fun!"),a.createElement(r.Z,null,(function(){var n=t(5933).Z;return a.createElement(n,null)})))))}}}]);