"use strict";(self.webpackChunkiso_fns_docs=self.webpackChunkiso_fns_docs||[]).push([[671],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=m(n),u=i,h=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var m=2;m<o;m++)r[m]=n[m];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9881:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return c},default:function(){return d}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],s={sidebar_position:1},l="Intro",m={unversionedId:"intro",id:"intro",isDocsHomePage:!1,title:"Intro",description:"iso-fns is the only multi-domain, immutable, functional DateTime package for JavaScript. Its goal is to help you write bug free date/time logic without all the hassle. Inspired by date-fns, js-joda, and the Temporal Proposal for EcmaScript, iso-fns seeks to be simple, feature-rich, and performant.",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",next:{title:"Why Strings?",permalink:"/docs/why-strings"}},c=[{value:"Multi-domain",id:"multi-domain",children:[],level:3},{value:"Immutable",id:"immutable",children:[],level:3},{value:"Functional",id:"functional",children:[],level:3}],p={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"intro"},"Intro"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," is the only ",(0,o.kt)("strong",{parentName:"p"},"multi-domain"),", ",(0,o.kt)("strong",{parentName:"p"},"immutable"),", ",(0,o.kt)("strong",{parentName:"p"},"functional")," DateTime package for JavaScript. Its goal is to help you write ",(0,o.kt)("strong",{parentName:"p"},"bug free")," date/time logic without all the hassle. Inspired by ",(0,o.kt)("a",{parentName:"p",href:"https://date-fns.org"},"date-fns"),", ",(0,o.kt)("a",{parentName:"p",href:"https://js-joda.github.io/js-joda/"},"js-joda"),", and the ",(0,o.kt)("a",{parentName:"p",href:"https://tc39.es/proposal-temporal/docs/"},"Temporal Proposal for EcmaScript"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," seeks to be simple, feature-rich, and performant."),(0,o.kt)("h3",{id:"multi-domain"},"Multi-domain"),(0,o.kt)("p",null,"Dates and times are complicated. JavaScript's native ",(0,o.kt)("inlineCode",{parentName:"p"},"Date")," object, while simple, does not have the functionality required by many modern web apps and so it is often painful to use. Because of this pain, there is now a popular Temporal Proposal which addresses many of the limitations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Date")," object. ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," mirrors and builds upon the design of the Temporal Proposal. This means that ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," has ",(0,o.kt)("strong",{parentName:"p"},"eight")," date/time types."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Instant:")," a fixed point in time without regard to calendar or location, e.g. July 20, 1969, at 20:17 UTC."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ZonedDateTime:")," a timezone-aware date/time that represents a real event that has happened (or will happen) at a particular exact time from the perspective of a particular region on Earth, e.g. December 7th, 1995 at 3:24 AM in US Pacific time."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"DateTime:")," represents a calendar date and wall-clock time that does not carry time zone information, e.g. December 7th, 1995 at 3:00 PM. "),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Date"),": represents a calendar date that is not associated with a particular time or time zone, e.g. August 24th, 2006."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Time:")," represents a wall-clock time that is not associated with a particular date or time zone, e.g. 7:39 PM."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"YearMonth:"),' A date without a day component. This is useful to express things like "the October 2020 meeting".'),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"MonthDay"),': A date without a year component. This is useful to express things like "Bastille Day is on the 14th of July".'),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Duration:")," expresses a length of time, e.g. 5 minutes and 30 seconds. This is used for date/time arithmetic and for measuring differences between two dates/times.")),(0,o.kt)("h3",{id:"immutable"},"Immutable"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," is string based. This means that the data type for Instant, ZonedDateTime, Date, etc. is just a string, so naturally iso-types are immutable. Strings are portable, easy to inspect, easy to cache, and representable in JSON. Using strings also ensures compatibility with the Temporal Proposal when it becomes an approved part of EcmaScript."),(0,o.kt)("h3",{id:"functional"},"Functional"),(0,o.kt)("p",null,"Each operation in ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," is a function which inputs an iso8601 formatted string. This is similar to the model adopted by ",(0,o.kt)("inlineCode",{parentName:"p"},"date-fns"),". Lets take a look at an example."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"dateFns.subtract('2000-01-15', {days: 20}) // '1999-12-26'\n")),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"dateFns")," is a bag of functions used to operate on iso dates. We input a date (an ISO8601 formatted string) and what we want to subtract (20 days), and we receive ",(0,o.kt)("inlineCode",{parentName:"p"},"'1999-12-26'"),". Another ISO8601 formatted string."),(0,o.kt)("p",null,"Below are several more examples of functions offered by ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const instant1 = instantFns.fromEpochMilliseconds(0) // '1970-01-01T00:00:00.000Z'\nconst instant2 = instantFns.subtract(instant1, {hours: 3, minutes: 30}) // '1969-12-31T20:30:00.000Z'\n\nconst zDateTime1 = instantFns.toZonedDateTime(instant2, 'America/Chicago') // '1969-12-31T14:30:00.000-06:00[America/Chicago]'\nconst zDateTime2 = zonedDateTimeFns.withDate(zDateTime1, '2021-06-15') // '2021-06-15T14:30:00.000-05:00[America/Chicago]'\nconst zDateTime3 = zonedDateTimeFns.startOfDay(zDateTime2) // '2021-06-15T00:00:00.000-05:00[America/Chicago]'\n\nconst time1 = zonedDateTimeFns.toTime(zDateTime3) // '00:00:00.000'\nconst time2 = timeFns.add(time1, {hours: 6, minutes: 39, seconds: 30}) // '06:39:30.000'\nconst time3 = timeFns.round(time2, {smallestUnit: 'minute', roundingIncrement: 15}) // '06:45:00.000'\n\nconst dateTime1 = timeFns.toDateTime(time3, '2000-01-01') // '2000-01-01T06:45:00.000'\nconst dateTime2 = dateTimeFns.with(dateTime1, { year: 2010 }) // '2010-01-01T06:45:00.000'\nconst dateTime3 = dateTimeFns.withTime(dateTime2, '12:30:00.000') // '2010-01-01T12:30:00.000'\n\nconst monthDay1 = dateTimeFns.toMonthDay(dateTime3) // '--01-01' \nconst monthDay2 = monthDayFns.with(monthDay1, {month: 8 }) // '--08-01'\n\nconst date1 = monthDayFns.toDate(monthDay2, 2010) // '2010-08-01'\nconst date2 = dateFns.with(date1, { month: 12 }) // '2010-12-01'\nconst date3 = dateFns.subtract(date2, {days: 20}) // '2010-11-11'\n\nconst yearMonth1 = dateFns.toYearMonth(date3) // '2010-11'\nconst yearMonth2 = yearMonthFns.add(yearMonth1, {years: 4}) // '2014-11'\n\nconst duration1 = yearMonthFns.until(yearMonth2, '2018-06') // 'P3Y7M'\nconst duration2 = durationFns.round(duration1, { relativeTo: '2014-11-01', largestUnit: 'days' }) // 'P1308D'\nconst totalDays = durationFns.getDays(duration2) // 1308\n")),(0,o.kt)("p",null,"For method chaining, ",(0,o.kt)("inlineCode",{parentName:"p"},"iso-fns")," using a similar strategy as ",(0,o.kt)("a",{parentName:"p",href:"https://lodash.com"},"Lodash"),". Here is the above example, using chaining. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const instant = instantFns.fromEpochMilliseconds(0) // '1970-01-01T00:00:00.000Z'\nconst zonedDateTime = instantFns.chain(instant)\n  .subtract({ hours: 3, minutes: 30 })\n  .toZonedDateTime('America/Chicago')\n  .value()\n) // '1969-12-31T14:30:00.000-06:00[America/Chicago]'\n\nconst time = zonedDateTimeFns.chain(zonedDateTime)\n  .withDate('2021-06-15')\n  .startOfDay()\n  .toTime()\n  .value()\n) // '00:00:00.000'\n\nconst dateTime = timeFns.chain(time)\n  .add({ hours: 6, minutes: 39, seconds: 30 })\n  .round({ smallestUnit: 'minute', roundingIncrement: 15 })\n  .toDateTime('2000-01-01')\n  .value()\n) // '2000-01-01T06:45:00.000'\n\nconst monthDay = dateTimeFns.chain(dateTime)\n  .with({ year: 2010 })\n  .withTime('12:30:00.000')\n  .toMonthDay()\n  .value()\n) // '--01-01' \n\nconst date = monthDayFns.chain(monthDay)\n  .with({month: 8 })\n  .toDate(2010)\n  .value()\n) // '2010-08-01'\n\nconst yearMonth = dateFns.chain(date)\n  .with({ month: 12 })\n  .subtract({ days: 20 })\n  .toYearMonth()\n  .value()\n) // '2010-11'\n\nconst duration = yearMonthFns.chain(yearMonth)\n  .add({ years: 4 })\n  .until('2018-06')\n  .value()\n) // 'P3Y7M'\n\nconst totalDays = durationFns.chain(duration)\n  .round({ relativeTo: '2014-11-01', largestUnit: 'days' })\n  .getDays()\n  .value()\n) // 1308\n")))}d.isMDXComponent=!0}}]);